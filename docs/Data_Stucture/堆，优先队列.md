堆，优先队列

```c++
priority_queue <int,vector<int>,less<int> > p;
//即priority_queue<int> q;队首为最大的，逐次递减 
priority_queue <int,vector<int>,greater<int> > q;
//队首为最小的，逐次增大。

对于结构体的重载：
struct node 
{ 
	int x,y; 
	bool operator < (const node & a) const //重载运算符
	{ 
		return x<a.x; 
		//关于k.x的队首最小，逐次增大的构造。
	}
}k; 
priority_queue <node> q;
q.push((node){X,Y});
/*
或者是：
node temp;
temp.x=X,temp.y=Y;
q.push(temp);
*/

```

用堆实现动态查找中位数（可快速查找任何分位数？）

对于长度为$i$的数列，当$i$为奇数时中位数为，为偶数时，中位数取第$\displaystyle \frac{i}{2}$个，有数据流，动态求解当前的中位数。

使用两个堆，一个小根堆，一个大根堆。

用大根堆存放低位，小根堆存放其他数据。

对于某一轮，如果大根堆未满（实际上，大根堆的容量一定不会小于，故仅需进行一次移动），此数应和小根堆堆顶进行比较，若小于，将此数插入大根堆，否则，将小根堆堆顶插入大根堆，而此数插入小根堆。

如果大根堆已满，若此数小于大根堆堆顶，将大根堆堆顶插入小根堆，此数插入大根堆，否则此数插入小根堆。

每次输出大根堆堆顶即可。

时间复杂度为$O(nlog_2n)$

```c++
#include<bits/stdc++.h>
using namespace std;
priority_queue<int> q1;
priority_queue<int,vector<int>,greater<int> >q2;
int n,x;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		int cursize=(i+1)/2;
		if(q1.size()<cursize)
		{
			if(q2.empty()) 
				q1.push(x);
			else if(x<q2.top())
				q1.push(x);
			else
			{
				q1.push(q2.top());
				q2.pop();
				q2.push(x);
			}
		}
		else
		{
			if(x<q1.top())
			{
				q2.push(q1.top());
				q1.pop();
				q1.push(x);
			}
			else
				q2.push(x);
		}
		//if(i%2==1)
			cout<<q1.top()<<endl;
	}
	return 0;
}
```

