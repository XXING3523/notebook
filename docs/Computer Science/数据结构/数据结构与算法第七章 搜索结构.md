静态搜索结构

数据表，搜索表

顺序搜索

---

**二叉搜索树**：

**递归定义**：（如果不是空树）：左子树为空/左子树内所有结点关键码小于根结点关键码，右子树为空/右子树内所有结点关键码大于根节点关键码。

查找路径模拟二分查找的过程，自根向下路径经过节点关键码**不一定单调**

将二叉搜索树转为顺序序列，**使用中序遍历**。

**考点：二叉搜索树的建立（代码与手绘流程图）**：

```c++


```

二叉搜索树的搜索、插入与删除：

搜索：只需对根节点逐次比较，根据比较结果向左/右子树挪动即可，如果查找到空结点，则搜索失败。可使用**递归/非递归**实现

```c++
template<class E, class K>
BSTNode<E, K>* BST<E, K>::
Search (const K x, BSTNode<E, K> *ptr) 
{
//私有递归函数：在以ptr为根的二叉搜索树中搜索含x结点。找到则返回该结点地址，否则返回NULL。
    if (ptr == NULL) return NULL; 
    else if (x < ptr->data) return Search(x, ptr->left);
    else if (x > ptr->data) return Search(x, ptr->right);
    else return ptr;//搜索成功
};

template<class E, class K>
BSTNode<E, K>* BST<E, K>::
Search (const K x, BSTNode<E, K> *ptr) 
{
//非递归函数：作为对比，在当前以ptr为根二叉搜索树中搜索含x结点。找到则返回该结点地址，否则返回NULL
    if (ptr == NULL) return NULL; 
    BSTNode<E, K>* temp = ptr;
    while (temp != NULL) 
    {
        if (x == temp->data) return temp;
        if (x < temp->data) temp = temp->left;
		else temp = temp->right;
    }
    return NULL;
};

```

插入：先检查此元素是否已经存在（如果允许重复出现则另当别论），如果需要插入，在逐次向下搜索时，若找到叶节点，则与之比较，根据结果将新数插入到其左/右孩子处。

```c++
template <class E, class K>
bool BST<E, K>::Insert (const E& e1, BSTNode<E, K> *& ptr) 
{	   
//私有函数：在以ptr为根的二叉搜索树中插入值为e1的结点。若在树中已有含e1的结点则不插入
    if (ptr == NULL) 
    {//新结点作为叶结点插入
        ptr = new BstNode<E, K>(e1);	  //创建新结点
        if (ptr == NULL)
        { 
            cerr << "Out of space" << endl;  exit(1); 
        }
	    return true;
	}
    else if (e1 < ptr->data) Insert (e1, ptr->left);//左子树插入
	else if (e1 > ptr->data) Insert (e1, ptr->right);//右子树插入
	else return false;//x已在树中,不再插入
};

template <class E, class K>
BST<E, K>::BST (K value) 
{
//输入一个元素序列, 建立一棵二叉搜索树
    E x;  
    root = NULL;  RefValue = value;//置空树
    cin >> x;
    while ( x.key != RefValue) 
    {//RefValue是一个输入结束标志
         Insert (x, root);  cin >> x;
    }
};


```

删除：被删节点是叶节点，将此指针置为空再释放即可

**如果是非叶节点，则在删除后需要连接断开的二叉树。**被删结点右子树为空，使用左子女顶替其位置。被删结点左子树为空，使用右子女顶替其位置。

被删结点左右子树均不为空，取**其右子树中序遍历下第一个节点**（关键码在右子树中最小），用其顶替，再处理此结点删除问题（**此时转为被删结点左子树为空情况**）；或取**其左子树中序遍历最后一个节点**（关键码在左子树中最大），用其顶替，再处理此结点删除问题（**此时转为被删结点右子树为空情况**）

```c++
template <class E, class K>
bool BST<E, K>::Remove (const K x, BstNode<E, K> *& ptr) 
{
//在以 ptr 为根的二叉搜索树中删除含 x 的结点
    BstNode<E, K> *temp;
    if (ptr != NULL) 
    {
         if (x < ptr->data) Remove (x, ptr->left);	
	     else if (x > ptr->data) Remove (x, ptr->right);
		 else if (ptr->left != NULL && ptr->right != NULL)
         {//ptr指示关键码为x的结点，它有两个子女
             temp = ptr->right;//到右子树搜寻中序下第一个结点
             while (temp->left != NULL) 
                 temp = temp->left;
             ptr->data = temp->data;//用该结点数据代替根结点数据
		     Remove (ptr->data, ptr->right);
         }
	     else
         {//ptr指示关键码为x的结点有一个子女
		 	temp = ptr;
		    if (ptr->left == NULL) ptr = ptr->right;
            else ptr = ptr->left;
            delete temp;
            return true;
         }
	}
	return false;
}; 

        
```

插入一个元素，再删除之，前后两种树**不一定相同**。

如果此元素不存在于树中，是相同的；如果存在于树中，则不一定相同（**如果删除的不是叶结点**）。

给定长度为$n$序列，构建的二叉搜索树最差高度是$n-1$,

---

**AVL树**

其或者是空树，或者是具有下列性质的二叉搜索树：其左子树，右子树均为AVL树，且左子树，右子树高度之差的绝对值不超过1。

**BF：节点的平衡因子**：即该节点右子树与左子树的高度差，此取值只能为-1，0，1三种，否则此树失去平衡，如果均能保持，则树的高度可以保持在$O(\log_2n)$，平均搜索长度也可以保持在$O(\log_2n)$

平衡化旋转：

单旋转（左旋/右旋），双旋转（左平衡/右平衡）

每插入一个新结点时，如果在某结点发现高度不平衡，停止回溯。从发生不平衡的结点起，沿**刚才回溯的路径**取直接下两层的结点。

如果这三个结点处于一条直线上，则单旋转，单旋转可按其方向分为左单旋转/右单旋转,其中一个是另一个的镜像，其方向与不平衡的形状相关。

如果这三个结点**处于一条折线**上，则双旋转，双旋转分为先左后右/先右后左旋转。

左单旋转：

右单旋转：

左右双旋：

右左双旋：



AVL树的删除：

被删结点x最多只一个子女，做简单删除：将x删去，把x的双亲中原指向x指针改指到此子女；若x无子女，此指针置NULL。将原以结点x为根的子树高度减1。

被删结点x有两个子女：取x在中序次序下直接前驱y(也可找直接后继)，把y的内容传给x，问题转到删结点y。把y当作被删结点x。因y最多有一个子女，可用前者操作。

必须沿x通向根路径反向追踪高度变化对路径上各结点影响。



用布尔变量shorter（缩短）指明子树高度是否被缩短。在每个结点上要做的操作取决于shorter值和结点bf，有时要依赖子女bf。shorter初始True。对从x双亲到根的路径上各个结点p，在shorter为True时执行下面操作。如果shorter变False，算法终止。当前结点p的bf为0。如果它的左子树或右子树被缩短，则bf改为1/-1，shorter置False。

p的bf不为0且较高子树被缩短。则p的bf置0，置shorter为True。

p的bf不为0，且较矮子树被缩短。则在p不平衡。令p较高子树根为q（该子树未被缩短），根据q的bf，有如下3种平衡化操作。旋转的方向取决结点p的哪一棵子树被缩短。

1）q（较高的子树）的bf为0，执行一个单旋转恢复p平衡，置shorter为False。无需检查上层结点bf。

2）q的bf与p的bf相同，执行一个单旋转恢复平衡，p和q的bf均置0，置shorter为True。继续检查上层结点bf。

3）p与q的bf相反，执行一个双旋转恢复平衡。先绕q转再绕p转。新根bf置0，其他结点bf相应处理，置shorter为True。



AVL树的高度，插入时间取决于树高。记$N_h$是高度为$h$的AVL树的最小节点数，根的两棵子树高度分别为$h-1,h-2$，子树满足AVL树定义，有：

$$N_0=0,N_1=1,N_h=N_{h-1}+N_{h-2}+1,h>1$$

可得$N_h+1=(N_{h-1}+1)+(N_{h-2}+1)$,记$N_h+1=f_h,f_h=f_{h-1}+f_{h-2},f_h=fibonacci_{h+2}$;

$\displaystyle fibonacci_h \approx (\frac{1+\sqrt{5}}{2})^h/\sqrt{5}$

$\displaystyle N_h\approx (\frac{1+\sqrt{5}}{2})^{h+2}/\sqrt{5}-1$

有$n$个结点的AVL树高度不超过$O(\log_2n)$，故删除节点并做平衡化旋转/插入数据时间为$O(\log_2n)$

二叉搜索树适合较小数据规模。对于一般的，使用B树，B+树。





