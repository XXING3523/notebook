树与森林的概念

度：结点的**子女个数**即为该结点的度；树中**各个结点的度的最大值**称为**树的度**。

结点的层次：**规定根结点在第一层**，其子女结点的层次等于它的层次加一。以下类推。

结点的深度：**结点的深度即为结点的层次**；**离根最远结点的层次即为树的深度**。

结点的高度：规定**叶结点的高度为1**，其双亲结点的高度等于它的高度加一。

有序树/无序树，树中结点的各棵子树是有次序的/无次序的，可以/不可以互相交换位置。

二叉树

【2025NJU期中、8分】根据先序、中序序列/中序、后序序列确定一棵二叉树

【2025NJU期中】对任何一棵二叉树，如果其叶结点有 $n_0$ 个, 度为2的非叶结点有 $n_2$ 个, 则有$n_0＝n_2+1$

二叉树的顺序表示（空间利用率无法保证）

二叉树的链表表示（二叉链表，三叉链表）

```c++
二叉树的类定义
template <class T> 
struct BinTreeNode 
{//二叉树结点类定义
     T data;//数据域
     BinTreeNode<T> *leftChild, *rightChild;
 	 //左子女、右子女链域
     BinTreeNode ()//构造函数
     { 
         leftChild = NULL;  
         rightChild = NULL; 
     }
	 BinTreeNode (T x, BinTreeNode<T> *l = NULL,  BinTreeNode<T> *r = NULL)
     { 
         data = x; 
         leftChild = l;  
         rightChild = r; 
     }
};

```

二叉树遍历

```c++
//中序遍历
template <class T>
void BinaryTree<T>::InOrder (BinTreeNode<T> * subTree, void (*visit) (BinTreeNode<T> *t)) 
{
     if (subTree != NULL) 
     {
          InOrder (subTree->leftChild, visit);//遍历左子树
          visit (subTree);//访问根结点
          InOrder (subTree->rightChild, visit); //遍历右子树
	 }
};
//前序遍历
template <class T>
void BinaryTree<T>::PreOrder (BinTreeNode<T> * subTree, void (*visit) (BinTreeNode<T> *t)) 
{
     if (subTree != NULL) 
     {
		visit (subTree);//访问根结点
		PreOrder (subTree->leftChild, visit);//遍历左子树
		PreOrder (subTree->rightChild, visit);//遍历右子树
	 }
};
//后序遍历
template <class T>
void BinaryTree<T>::PostOrder (BinTreeNode<T> * subTree, void (*visit) (BinTreeNode<T> *t ) 
{
     if (subTree != NULL ) 
     {
         PostOrder (subTree->leftChild, visit);//遍历左子树
		 PostOrder (subTree->rightChild, visit);//遍历右子树
		 visit (subTree);//访问根结点
	 }
};
//层次遍历
template <class T>
void BinaryTree<T>::LevelOrder (void (*visit) (BinTreeNode<T> *t)) 
{
     if (t == NULL) return;
     Queue<BinTreeNode<T> * > Q;
     BinTreeNode<T> *p = t;   
     Q.EnQueue (p);
     while (!Q.IsEmpty ()) 
     {
          Q.DeQueue (p); visit (p); 
          if (p->leftChild != NULL)   Q.EnQueue (p->leftChild);
          if (p->rightChild != NULL)   Q.EnQueue (p->rightChild);
     }
};      

```

```c++
//栈的前序遍历非递归算法
template <class T> 
void BinaryTree<T>::PreOrder (void (*visit) (BinTreeNode<T> *t) ) 
{
     stack<BinTreeNode<T>*> S;
     BinTreeNode<T> *p = t; 
     S.Push (NULL);
	 while (p != NULL) 
     {
          visit(p);//访问结点
 	      if (p->rightChild != NULL)
               S.Push (p->rightChild);//预留右指针在栈中
          if (p->leftChild != NULL) 
               p = p->leftChild;//进左子树
 	      else S.Pop(p);//左子树为空，取出栈顶设为p，退栈。
     }
};
//栈的中序遍历非递归算法
template <class T> 
void BinaryTree<T>::
InOrder (void (*visit) (BinTreeNode<T> *t)) 
{
    stack<BinTreeNode<T>*> S;
    BinTreeNode<T> *p = t;
    do
    {
        while (p != NULL)
        {//遍历指针向左下移动
            S.Push (p);//该子树沿途结点进栈
            p = p->leftChild;
        }
        if (!S.IsEmpty())
        {//栈不空时退栈
            S.Pop (p);
            visit (p);//退栈, 访问
            p = p->rightChild;//遍历指针进到右子女
        }
    }while (p != NULL || !S.IsEmpty ());
};
//栈的后序遍历非递归算法
template <class T>
    struct stkNode 
    {
	     BinTreeNode<T> *ptr;//树结点指针	        
         enum tag {L, R};//退栈标记
  	     stkNode (BinTreeNode<T> *N = NULL) :
             ptr(N), tag(L) { }//构造函数
	};
tag = L，表示从左子树退回还要遍历右子树；
tag = R，表示从右子树退回要访问根结点。
template <class T>
void BinaryTree<T>::PostOrder (void (*visit) (BinTreeNode<T> *t) 
{
     Stack<stkNode<T>> S;   stkNode<T> w; 
     BinTreeNode<T> * p = t;//p是遍历指针
	 do 
     {
		 while (p != NULL) 
         {	
		     w.ptr = p; 
             w.tag = L;  
             S.Push (w);   
		     p = p->leftChild;					
         }
	 	int continue1 = 1;//继续循环标记, 用于R
		while (continue1 && !S.IsEmpty ()) 
        {
		     S.Pop (w);  
             p = w.ptr;
		     switch (w.tag) 
             {//判断栈顶的tag标记
 		 	 	 case L:  
                     w.tag = R;  
                     S.Push (w); 
				     continue1 = 0;  
			      	 p = p->rightChild; 
                     break;
		         case R:  
                     visit (p);  
                     break;	
	         }
	 	}
     } while (!S.IsEmpty ());//继续遍历其他结点
     cout << endl;
};

```

利用二叉树前序遍历建立二叉树

ABC@@DE@G@@F@@@

以递归方式建立二叉树。输入结点值的顺序必须对应二叉树结点前序遍历的顺序，并约定以输入序列中不可能出现的值作为空结点的值以结束递归,



```c++
template<class T> 
void BinaryTree<T>::CreateBinTree (ifstream& in, BinTreeNode<T> *&subTree) 
{
//私有函数: 以递归方式建立二叉树。
     T item;
     if ( !in.eof () ) 
     {//未读完, 读入并建树	
         in >> item;//读入根结点的值
	     if (item != RefValue) 
         {
             subTree = new BinTreeNode<T>(item);
    	     //建立根结点
             if (subTree == NULL) 
	         {
                 cerr << “存储分配错!” << endl;  
                 exit (1);
             }
	         CreateBinTree (in, subTree->leftChild);//递归建立左子树
			 CreateBinTree (in, subTree->rightChild);//递归建立右子树
          }
 		  else subTree = NULL;//封闭指向空子树的指针
     }
};


```

【2025NJU期中，8分】线索化二叉树

通过二叉树的遍历，可将二叉树中所有结点的数据排列在一个线性序列中，可以找到某数据在这种排列下它的前驱和后继。

希望不必每次都通过遍历找出这样的线性序列。只要事先做预处理，将某种遍历顺序下的前驱、后继关系记在树的存储结构中，以后就可以高效地找出某结点的前驱、后继。

ltag 和 rtag，指明指针是指示子女还是前驱／后继。后者称为线索。

ltag (或rtag) = 0，表示相应指针指示左子女（或右子女结点）；当ltag (或rtag) = 1, 表示相应指针为前驱（或后继）线索。

```c++
通过中序遍历建立中序线索化二叉树
template <class T>
void ThreadTree<T>::createInThread () {
     ThreadNode<T> *pre = NULL;    //前驱结点指针
	 if (root != NULL) {   	         //非空二叉树, 线索化
          createInThread (root, pre);				    //中序遍历线索化二叉树
	      pre->rightChild = NULL;  pre->rtag = 1;		   //后处理中序最后一个结点
	 }
};
template <class T>
void ThreadTree<T>::createInThread (ThreadNode<T> *current,ThreadNode<T> *& pre)
{//通过中序遍历, 对二叉树进行线索化
     if (current == NULL) return;
     createInThread (current->leftChild, pre);//递归, 左子树线索化
	 if (current->leftChild == NULL) 
     {//建立当前结点的前驱线索
         current->leftChild = pre;
         current->ltag = 1; 
     }
     if (pre != NULL && pre->rightChild == NULL)//建立前驱结点的后继线索
     { 
         pre->rightChild = current;   
         pre->rtag = 1; 
     }	
     pre = current;//前驱跟上,当前指针向前遍历
	 createInThread (current->rightChild,  pre);//递归, 右子树线索化
};

```

**【2025NJU期中】根据给出的二叉树画出相对应遍历顺序的线索树**

【2025NJU期中，2分】$n$个结点的线索二叉树上含有的线索数为？$\boxed{n+1}$

```c++
struct Node 
{
	Node *lchild;
    Node *rchild;
    int ltag;  // 0表示指向左子树，1表示指向前驱
    int rtag;  // 0表示指向右子树，1表示指向后继
    int data;
}
/*
如果ltag=1，lchild指针就是前驱，rtag=1，rchild指针就是后继。
当ltag=0,rtag=0时，需要结合树的结构判断：
对于前序遍历：
==查找p的后继==
因为前序遍历的规则，我们先判左子女，再判右子女
如果p->ltag=0，说明存在左子女，后继为p->leftchild;
否则左子女代表前驱线索，接下来考虑右子女：
若p->rightchild==NULL，则不存在后继。
否则后继为p->rightchild，无论rtag。
对于中序遍历：
==查找p的前驱==
如果p->ltag=1，前驱为p->leftchild;
否则，前驱为p的左子树中序遍历下最后一个节点
==查找p的后继==
如果p->rtag=1，后继为p->rightchild;
否则，后继为p的右子树中序遍历下第一个节点
对于后序遍历：
==查找p的后继==
如果p->rtag=1，后继为p->rightchild;
否则p存在右子女，则右子女及右子树先于p遍历完，若(q->parent,q==NULL),则p没有祖先，即没有后继。
若q不为NULL，考虑p为q的左子女还是右子女，即(q->rtag==1||q->rightchild==p)，若为真，则说明q为p的后继（前者为真自不必说，后者为真则p为q右子树的根节点，后继自然为q），若为假，则说明（q->rtag==0&&q->rightchild!=p）：q有右子树，且p为q的左子树根节点：故后继为q的右子树中后序下第一个结点。

*/
```

树与森林

树的存储方式

1）广义表表示

2）双亲表示（存data和parent）

3）子女链表表示（无序树情形链表中各结点顺序任意，有序树必须自左向右链接各个子女结点。）

4）子女-指针表示：**每一个结点包含的指针个数为树的度，记为$d$，则空指针数为$nd-n+1$**

5）**子女—兄弟表示（存第一个子女与兄弟）**



**【2025NJU期中，4分】**==**先根次序遍历**==（对应**子女—兄弟表示**二叉树**表示前序遍历**），**==后根次序遍历==（根最后访问）（对应子女—兄弟表示二叉树表示中序遍历）**

广度优先（层次次序）遍历

将一般树化为二叉树表示就是用树的子女-兄弟表示来存储树的结构。森林与二叉树表示的转换可以借助树的二叉树表示来实现。

将森林借助子女—兄弟表示法转化为二叉树，其中根均为兄弟，**先转各树，再转森林**。

森林的两种遍历同树的两种遍历



```c++
//子女——兄弟表示二叉树的广度优先遍历
template <class T> 
void Tree<T>::LevelOrder(void (*visit) (BinTreeNode<T> *t) ) 
{
//按广度优先次序分层遍历树, 树的根结点是当前指针current。
    Queue<TreeNode<T>*> Q;
         TreeNode<T> *p;
         if (current != NULL) 
         {//树不空 
              p = current;//保存当前指针
              Q.EnQueue (current);//根结点进队列
              while (!Q.IsEmpty ()) 
              {
                    Q.DeQueue (current);//退出队列
                    visit (current);//访问之
                    current = current->firstChild;
                    while (current != NULL) 
                    { 
                        Q.EnQueue (current);
                        current = current->nextSibling;
                    }
              }
              current = p;//恢复算法开始的当前指针
         }
};
```



【2025NJU期中，6分】**堆**

一种完全二叉树，且每个节点均小于其左右孩子（或均大于其左右孩子）

**==（重点）会画直接调整，单次插入，单次删除的流程==**

```c++
最小堆的类定义
template <class E>
class MinHeap : public MinPQ<E> 
{
//最小堆继承了（最小）优先级队列
public: 
     MinHeap (int sz = DefaultSize);//构造函数
     MinHeap (E arr[], int n);//构造函数
     ～MinHeap() { delete [ ] heap; }//析构函数
     bool Insert (E& x);//插入
     bool Remove (E& x);//删除
     bool IsEmpty () const//判堆空否
     { 
         return  currentSize == 0; 
     }
     bool IsFull () const//判堆满否
 	 { 
         return currentSize == maxHeapSize; 
     }	
	 void MakeEmpty ()
     {
         currentSize = 0; 
     }//置空堆
private: 
     E *heap;//最小堆元素存储数组
     int currentSize;//最小堆当前元素个数
     int maxHeapSize;//最小堆最大容量
     void siftDown (int start, int m);//调整算法（下滑）
     void siftUp (int start);//调整算法（上滑）
};


```

将一组用数组存放的任意数据调整成堆的方法：

方法一：逐个插入，$O(n\log_2n)$

实际上：时间复杂度可视作$O(\log_2{n!})$,考虑$\displaystyle \frac{\log_2{n!}}{n}$

方法二：直接调整，$O(n)$

所以，选用优的方式，构建堆的时间复杂度为$O(n)$

最小堆的每次插入，时间复杂度为$O(\log_2n)$

```c++
template <class E>
MinHeap<E>::MinHeap (int sz) 
{
     maxHeapSize = (DefaultSize < sz) ? sz : DefaultSize;
     //三目运算符的解释：wei'zhen
     heap = new E[maxHeapSize];//创建堆空间
     if (heap == NULL) 
     {
          cerr << “堆存储分配失败！” << endl;  exit(1);
     }
     currentSize = 0;//建立当前大小
};
template <class E>
MinHeap<E>::MinHeap (E arr[], int n) 
{
     maxHeapSize = (DefaultSize < n) ? n : DefaultSize;
     heap = new E[maxHeapSize]; 
	 if (heap == NULL) 
	 {
        cerr << “堆存储分配失败！” << endl;  exit(1);
     }
     for (int i = 0; i < n; i++) heap[i] = arr[i];
     currentSize = n;//复制堆数组, 建立当前大小
	 int currentPos = (currentSize-2)/2;	
     //找最初调整位置:最后分支结点
     while (currentPos >= 0) 
     {	    //逐步向上扩大堆
           siftDown (currentPos, currentSize-1);
           	//局部自上向下下滑调整
           currentPos--;
     }					
};

//最小堆下滑调整算法
template <class E>
void MinHeap<E>::siftDown (int start, int m ) 
{
//私有函数: 从结点start开始到m为止, 自上向下比较, 
//如果子女的值小于父结点的值,则关键码小的上浮, 
//继续向下层比较, 将一个集合局部调整为最小堆。
//由于堆存储在下标从 0 开始计数的一维数组中，故结点下标不超过n-1
	int i = start,j = 2*i+1;//j是i的左子女位置
	E temp = heap[i]; 			
	while (j <= m) 
    {//检查是否到最后位置
	    if ( j < m && heap[j] > heap[j+1] ) j++;//让j指向两子女中的小者
		if ( temp <= heap[j] ) break;//小则不做调整
		else 
        { 
            heap[i] = heap[j];  
            i = j; 
            j = 2*j+1; 
        }//否则小者上移, i, j下降
	 }
	 heap[i] = temp;//回放temp中暂存的元素，即将i的值放到它应该要去的位置
};

//最小堆的插入
//每次插入都加在堆的最后，再自下向上执行调整，使之重新形成堆
template <class E>
bool MinHeap<E>::Insert (const E& x )  {
//公共函数: 将x插入到最小堆中
    if ( currentSize == maxHeapSize )
    { 
        cerr << "Heap Full" << endl;
        return false; 
    }
	heap[currentSize] = x;//插入
	siftUp (currentSize);//向上调整
	currentSize++;//堆计数加1，此处借当前插入个数与末尾下标玩了个花招
	return true;
};
template <class E>
void MinHeap<E>::siftUp (int start) 
{
//私有函数: 从结点start开始到结点0为止, 自下向上
//比较, 如果子女的值小于父结点的值, 则相互交换, 
//这样将集合重新调整为最小堆。关键码比较符<=
//在E中定义。
    int j = start,i = (j-1)/2;//j表示起始结点位置，i表示其父亲位置 
    E temp = heap[j];//这一句是什么意思？也就是这个j的值应该要去的位置。
	while (j > 0) //j=0则不用向上调整了。
    {//沿父结点路径向上直达根
		if (heap[i] <= temp) break;//父结点值小, 不调整
		else 
        { 
            heap[j] = heap[i];//这里的赋值只是换掉原先的位置，对于最终位置的赋值没有考虑
            j = i;  
            i = (i-1)/2; 
        }
		//父结点结点值大, 调整
	}	
	heap[j] = temp;//回送
};

//最小堆的删除（注意维持堆的完全二叉树的形态）只能删除头节点（也就是优先队列队头）
template <class E>
bool MinHeap<E>::Remove (E& x) 
{
	if ( !currentSize ) 
    {
	    cout << "Heap empty" << endl;  
        return false;
    }
	x = heap[0];  
	heap[0] = heap[currentSize-1];
    currentSize--;
    siftDown(0, currentSize-1);//自上向下调整为堆
	return true;			//返回最小元素
};


```

**Huffman树**

**【2025NJU期中】会画构造Huffman树的流程图。**

路径长度（PL）：连接两结点路径上分支构成路径，长度为分支数。

外部路径长度（$EPL$）：各叶结点（外结点）到根结点的路径长度之和。

内部路径长度（$IPL$）：各非叶结点（内结点）到根结点的路径长度之和。

树的路径长度为$EPL+IPL$。

$n$个节点的二叉树路径数不小于下述数列前$n$项和：$\displaystyle \sum_{i=1}^{n} floor( \log_2i)  $,$\displaystyle \sum_{i=1}^{n} \lfloor \log_2 i \rfloor$，完全二叉树满足此要求。

带权路径长度，权$w_i$为**外结点**所带，其到根的路径长度为$l_i$，树的带权路径长度为$\displaystyle WPL=\sum_{i=1}^{n}w_i*l_i$

**注意：带权路径长度的计算只考虑外结点**

**带权路径长度达到最小的扩充二叉树即为Huffman树。在Huffman树中，权值大的结点离根最近。**

```c++
//Huffman树类定义
#include "heap.h"
const int DefaultSize = 20;//缺省权值集合大小
template <class E>
struct HuffmanNode 
{//树结点的类定义
     E data;//结点数据
	 HuffmanNode<E> *parent;
     HuffmanNode<E> *leftChild, *rightChild;//左、右子女和父结点指针
	 HuffmanNode () : parent(NULL), leftChild(NULL),rightChild(NULL) { }
     //构造函数	
HuffmanNode(E elem,//构造函数
         HuffmanNode<E> *pr = NULL, 
         HuffmanNode<E> *left = NULL,		
	     HuffmanNode<E> *right = NULL) 
             : data (elem), parent (pr), leftChild (left),  
               rightChild (right) { }	
};
 template <class E>
class HuffmanTree {		//Huffman树类定义
public:
     HuffmanTree (E w[], int n);	//构造函数
     ～HuffmanTree() {deleteTree (root);}  //析构函数
protected:
     HuffmanNode<E> *root;	     //树的根
     void deleteTree (HuffmanNode<E> *t);			//删除以 t 为根的子树
     void mergeTree (HuffmanNode<E>& ht1, 		HuffmanNode<E>& ht2,   
          HuffmanNode<E> *& parent)；
};



template <class E>
HuffmanTree<E>::HuffmanTree (E w[], int n) {
//给出 n 个权值w[0]～w[n-1], 构造Huffman树
     minHeap<E> hp;//使用最小堆存放森林
     HuffmanNode<E> *parent, &first, &second; 
     HuffmanNode<E> *NodeList = new HuffmanNode<E>[n];//森林
     for (int i = 0; i < n; i++) 
     {
          NodeList[i].data = w[i];
		  NodeList[i].leftChild = NULL;       
          NodeList[i].rightChild = NULL;
          NodeList[i].parent = NULL;
          hp.Insert(NodeList[i]);//插入最小堆中
     }
     for (i = 0; i < n - 1; i++) 
     {//n-1趟, 建Huffman树
          hp.Remove (first);//根权值最小的树
          hp.Remove (second);//根权值次小的树
		  mergeTree (first, second, parent);//合并
          hp.Insert (*parent);//重新插入堆中
     }
     root = parent;//建立根结点
};
template <class E>
void HuffmanTree<E>::
mergeTree (HuffmanNode<E>& bt1, HuffmanNode<E>& bt2, HuffmanNode<E> *& parent) 
{
     parent = new HuffmanNode<E>;
     parent->leftChild = &bt1;
     parent->rightChild = &bt2;
	 parent->data.key = bt1.root->data.key + bt2.root->data.key;
     bt1.root->parent = bt2.root->parent = parent; 
}; 



```

**Huffman编码，实现数据压缩。**先进行Huffman树构建，再进行分支编码。而且此种编码是一种前缀编码，即任一个二进制编码不是其他二进制编码的前缀，解码时不会混淆，例如A=0，T=00，来了00是解码成T还是AA呢？

