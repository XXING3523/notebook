```c++
若想在线性表中存放不同类型的数据，可采用等价定义union：
typedef union 
{          
	int val;//按data.val引用	       
	char ch;//按data.ch引用          
	float dir;//按data.dir引用	 
}  
data;            
//整体上是同一类型data
对struct，所有成员各自分配空间，大小是所有成员大小之和，所有成员可以同时使用，表示一组不同数据的集合
对union，所有成员共用一块内存，==大小是最大成员的大小==，==同一时刻只有一个成员有效==，节省内存，实现多种数据类型的复用。如果反复对同一个union变量内的不同成员赋值，可能会相互覆盖。
注：
sizeof(type)返回的是类型type在内存中占用字节数
sizeof(int)通常为4
sizeof(variable)返回变量 variable 所占用的字节数
但是对于
struct 
{
    char c;
    int i;
}s;
printf("sizeof(s) = %zu\n", sizeof(s)); 的值可能大于成员简单相加（受内存对齐影响）。
    
    
内存对齐：

```

内存对齐（Memory Alignment）是计算机系统为了提高存取效率，对数据在内存中存放地址的约束规则。它要求**某些类型的数据对象的起始地址必须是特定的倍数**（通常是数据类型大小的倍数）。

- 现代CPU访问内存通常以**字（word）** 为单位，访问未对齐的数据可能需要额外的读写操作，导致性能下降。
- 硬件平台对未对齐访问可能不支持，甚至产生异常。
- 因此，编译器会自动插入“填充字节”（padding），使得结构体成员按对齐规则排列。

```c++
假设int需要4字节对齐
struct Example 
{
    char c;    // 1字节（0，1-3为填充字节）
    int i;     // 4字节（4-7）
};
结构体实际大小为8字节，不是5字节。

p=malloc(10*sizeof(int));
p=new int[10];
free(p);
delete []p;
```

C++的函数特征

C++的数据声明

C++的作用域

C++的类

C++的对象

C++的输入/输出

C++的函数

C++的参数传递

C++的函数名重载和操作符重载

C++的动态存储分配

友元(friend)函数

内联(inline)函数

结构(struct)与类

联合(Union)与类
