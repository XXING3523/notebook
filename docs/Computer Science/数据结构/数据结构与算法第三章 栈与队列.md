数据结构与算法第三章 栈与队列

---

栈

栈顶/栈底/后进先出（LIFO）（Last In First Out）/上溢/下溢

计算后缀表达式，中缀表达式转后缀表达式

**如何合理进行栈空间分配，以避免栈溢出或空间的浪费？**

**双栈共享一个栈空间（多栈共享栈空间）**

两个栈共享一个数组空间$V[maxSize]$

$t[i]$和$b[i]$分别指示第$i$个栈的栈顶与栈底，初始$t[0]=b[0]=-1$,$t[1]=b[1]=maxSize$

栈满条件：$t[0]+1=t[1]$（栈顶指针相遇）

栈空条件：$t[0] = b[0]||t[1] = b[1]$

**栈的链接存储方式—— 链式栈**

链式栈无栈满问题，空间可扩充

插入与删除仅在栈顶处执行

链式栈的栈顶在链头

适合于多栈操作（一个链中可准备多个栈顶标记）

---

使用递归的场景

定义是递归的/数据结构是递归的/问题解法是递归的

**==（重点）绘制递归调用树（直接做题或者是用于辅助）==**

---

队列

队头/队尾/先进先出（FIFO）（First In First Out）

我们选用参数front，rear来指示队首，队尾（当前队尾元素的后一个空位）的位置，队尾做入队，队首读数据与做出队，要特别注意rear可以小于front（将队列元素存放数组首尾相接，形成循环队列）

```c++
队头指针进1:  front = (front+1) % maxSize;
队尾指针进1:  rear = (rear+1) % maxSize;
队列初始化：front = rear = 0;
队空条件：front == rear;
队满条件：(rear+1) % maxSize == front;
队列所存元素个数:(rear + k - front) % k;

void MakeEmpty() 
{ 
     front = rear = 0; 
}
int IsEmpty() const 
{ 
    return front == rear; 
}
int IsFull() const
{ 
    return (rear+1) % maxSize == front; 
}
    
template <class E> 
SeqQueue<E>::SeqQueue(int sz) : front(0), rear(0), maxSize(sz) 
{//构造函数
      elements = new E[maxSize];		
      assert ( elements != NULL );
};
template <class E>
bool SeqQueue<E>::EnQueue(E x) 
{           
//若队列不满, 则将x插入到该队列队尾, 否则返回      
    if (IsFull() == true) return false;   
    elements[rear] = x;//先存入
    rear = (rear+1) % maxSize;//尾指针加一
    return true;
};
template <class E>
bool SeqQueue<E>::DeQueue(E& x) 
{ 
//若队列不空则函数退队头元素并返回其值
    if (IsEmpty() == true) return false;  
	x = elements[front];                  //先取队头
    front = (front+1) % maxSize;   //再队头指针加一
    return true;
};
template <class E>
bool SeqQueue<E>::getFront(E& x) const 
{
//若队列不空则函数返回该队列队头元素的值
     if (IsEmpty() == true) return false;//队列空
	 x = elements[front];//返回队头元素
	 return true;
}; 

```

链式队列
队头在链头，队尾在链尾。链式队列在进队时无队满问题，但有队空问题。

队空条件为 front == NULL （还是front == rear）

```c++
#include <iostream.h>
#include “Queue.h”
template <class E>
struct QueueNode 
{//队列结点类定义	
private: 
    E data;//队列结点数据
    QueueNode<E> *link;//结点链指针
public:
    QueueNode(E d = 0, QueueNode<E>*next = NULL) : data(d), link(next) { }
};  
template <class E>
class LinkedQueue 
{	
private: 
     QueueNode<E> *front, *rear;//队头、队尾指针
public: 
    LinkedQueue() : rear(NULL), front(NULL) { }
    ~LinkedQueue();					
    bool EnQueue(E x);
    bool DeQueue(E& x);			
    bool GetFront(E& x);			
    void MakeEmpty();//实现与~Queue()同
    bool IsEmpty() const { return front == NULL; }
};
template <class E>
LinkedQueue<E>::~LinkedQueue() 
{//析构函数
    QueueNode<E> *p;
    while (front != NULL) 
    {//逐个结点释放
        p = front;  front = front->link;  delete p;
    }
};

template <class E> 
bool LinkedQueue<E>::EnQueue(E x) 
{
//将新元素x插入到队列的队尾

        if (front == NULL)  
        {//创建第一个结点
	        front = rear = new QueueNode<E> (x);
            if (front == NULL) return false; 
        }//分配失败 
     	else 
        {//队列不空, 插入
            rear->link = new QueueNode<E> (x);
            if (rear->link == NULL) return false; 
            rear = rear->link;
     }
     return true;
};
template <class E>
//如果队列不空，将队头结点从链式队列中删去 
bool LinkedQueue<E>::DeQueue(E& x) 
{
     if (IsEmpty() == true) return false;//判队空
     QueueNode<E> *p = front;		
     x = front->data;  front = front->link;   
     delete p;   
     return true;				
};

template <class E> 
bool LinkedQueue<E>::GetFront(E& x) 
{
//若队列不空，则函数返回队头元素的值 
    if (IsEmpty() == true) return false; 	
    x = front->data;  
    return true;
};


```

利用队列打印二项展开式系数的算法

```c++
#include <stdio.h>
#include <iostream.h>
#include "queue.h"
void YANGHVI(int n) 
{
    Queue q(n+3);//队列初始化
    q.MakeEmpty();
    q.EnQueue(1);  q.EnQueue(1);	
    int s = 0, t;
    for (int i = 1; i <= n; i++) 
    {//逐行计算
        cout << endl;					
        q.EnQueue(0);					
        for (int j = 1; j <= i+2; j++) 
        {//下一行
            q.GetFront(t);  q.DeQueue();
            q.EnQueue(s + t);		
            s = t;
            if (j != i+2) cout << s << ' ';		
        }
    }
}
输出结果：1 1 1 2 1 1 3 3 1 ……

```

