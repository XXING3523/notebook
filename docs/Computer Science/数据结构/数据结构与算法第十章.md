第十章 文件，外部排序与外部搜索

主存储器和外存储器

主存储器即内存储器（内存），外存储器即外存。外存相比内存的的优点是：价格低、具备永久存储能力；缺点是：访问外存储器数据比访问内存要慢5到6个数量级。

磁带与磁盘

文件组织

文件是存储在外存上的数据结构

直接存取文件（散列文件）

（1）溢出链：与基桶大小相同，在基桶检索不成功，循指针转到溢出桶检索。

（2）分布式溢出空间：溢出桶按照一定间隔分布在基桶中间，若其中一个基桶溢出，将记录存在下一个溢出桶中，若溢出桶溢出，则使用下一个相继的溢出桶。

（3）相继溢出法：不设置溢出桶，当记录应存放的桶溢出时，溢出记录存放到下一个相继的桶中。

散列文件优点：随机存放、记录不需进行排序、插入删除方便、存取速度快、不需要索引区和节省存储空间

散列文件缺点：不能顺序存取，只能按关键码随机存取。经多次插入、删除后，可能出现溢出桶满而基桶内多数记录已被删除的情况。此时需重新组织文件。



索引文件

由索引表、数据表（主文件）组成。索引表用于指示逻辑记录与物理记录间对应关系$(key\to addr)$，是按关键码有序的表。

索引顺序文件：**主文件也按关键码有序**，可对主文件分组，一组记录（子表）对应一个索引项。称这种索引表为**稀疏索引**。

索引非顺序文件：主文件未按关键码有序，每一个主文件记录必须对应一个索引项。称这种索引表为**稠密索引**。

**静态索引**：**采用多级索引结构，每一级索引均为有序表。**优点：结构简单；缺点：修改麻烦，每次修改都要重组索引。

**动态索引**：采用**可动态调整的平衡搜索树结构**（二叉搜索树、B树、B+树）。优点：插入、删除和搜索都很方便。

文件检索时，访问外存所花时间比在内存中搜索所需的时间大得多。因此，外存上搜索一个记录的时间代价主要取决于访问外存的次数，即**索引树高度**。

索引顺序文件搜索成功时的平均搜索长度：$ASL_{suc}=ASL_{Index}+ASL_{SubList}$，前者是在索引表中搜索子表位置的平均搜索长度，后者是在子表内搜索记录位置的平均搜索长度。

设将长度为$n$的表均分为$b$个子表，每个子表$s$个记录，则$\displaystyle b=\lceil \frac{n}{s}\rceil$。设表中每个记录的搜索概率相等，对索引表和子表都用顺序搜索，则 $\displaystyle ASL_{suc}=\frac{b+s}{2}+1$ ，在给定$n$时，选择$s=\sqrt{n}$可以得到局部最短搜索长度$\sqrt{n}+1$；若采用折半搜索确定记录所在子表，有$\displaystyle ASL_{suc}=\log_2(b+1)-1+\frac{s+1}{2}$ 

多级索引结构

当数据记录数目特别大，索引表本身也很大，在内存中放不下，需要分批多次读取外存才能把索引表搜索一遍。

此时, 可以建立索引的索引(二级索引)。二级索引可以常驻内存，二级索引中一个索引项对应一个索引块，登记该索引块的最大关键码及该索引块的存储地址。如果二级索引在内存中也放不下，需要分为许多块多次从外存读入。可以建立二级索引的索引(三级索引)。这时, 访问外存次数等于读入索引次数再加上1次读取记录。

常用$m$叉树表示，称为$m$路搜索树

m路搜索树可能是静态索引结构，即结构在初始创建，数据装入时就已经定型，在整个运行期间，树的结构不发生变化。m路搜索树还可能是动态索引结构, 即在整个系统运行期间,  树的结构随数据的增删及时调整, 以保持最佳的搜索效率。

动态索引结构

动态的$m$路搜索树，满足如下性质：

（1）根最多有棵子树，并具有如下结构：

$$(n,P_0,K_1,P_1,K_2,P_2,\cdots,K_n,P_n)$$

其中$P_i$是指向子树的指针，$K_i$是关键码，且保持递增。

（2）子树$P_i$中所有关键码均小于$K_{i+1}$，且大于$K_i$，$P_0,P_n$仅需满足一侧条件。

（3）子树$P_i$也是$m$路搜索树。



B树（B-树）与B+树

$m$阶B树是一棵平衡的$m$路搜索树，不为空树则满足：

（1）根节点至少有2个子女

（2）除根结点以外的所有结点（不包括失败结点）至少有$\displaystyle \lceil \frac{m}{2}\rceil$个子女

（3）所有失败结点位于同一层（叶结点在同一层）



B树的搜索算法

搜索成功时间取决于关键码所在层次

搜索不成功时间取决于树高

设树中关键码有$N$个。

（1）当B树每层结点个数达到最大$m-1$时：

有$N\le m^h-1\to h\ge \lceil\log_m(N+1\rceil$

（2）当B树每层结点个数达到最小

**失败数据与已有关键码交错排列：$n$关键码将区间划分为$n+1$个失败区间**





插入

在某叶节点开始，若在结点插入关键码后数量溢出，则需分裂结点。

取位于中间的关键码$\displaystyle \lceil\frac{m}{2}\rceil$，将其移至双亲结点内，其左部结点、右部结点这两个集合分裂为两个子女结点。

最坏情况下，从被插关键码所在叶结点到根的路径上所有结点都要分裂。

删除

若结点中所剩关键码个数小于下限，应考虑结点的调整与合并问题。

（1）删除非叶结点：被删关键码为$K_i$，删去$K_i$之后, 以该结点$P_i$所指示子树中的最小关键码$x$来代替$K_i$位置，转为删除叶结点$x$操作。

（2）删除叶结点（直接删除，无后续处理）：是根结点且结点关键码个数$n\ge 2$，或是非根节点且结点关键码个数$\displaystyle n\ge \lceil\frac{m}{2}\rceil$，则直接删去此关键码，将修改结点回写磁盘。

（3）**（有后续处理）左右兄弟够用：**被删关键码所在叶结点删除前关键码个数$\displaystyle n= \lceil\frac{m}{2}\rceil-1$，若这时与该结点相邻右兄弟 (左兄弟) 结点关键码个数$\displaystyle n\ge \lceil\frac{m}{2}\rceil$，可按以下步骤处理：

- 将**双亲**结点中**刚大于 (小于) 被删关键码$K_{remove}$的关键码**$K_i$下移；
- 将**右兄弟 (左兄弟)** 结点中的**最小 (最大) 关键码**上移到**双亲结点**的$K_i$位置；
- 将**右兄弟 (左兄弟) **结点中的**最左 (最右) 子树指针**移到被删关键码所在结点中**最后 (最前) 子树指针位置**；
- 在**右兄弟 (左兄弟) **结点中，将被移走的关键码和指针位置**用剩余关键码和指针填补调整**。再将结点关键码个数减1。

（4）**（有后续处理）左右兄弟不够用：**被删关键码所在叶结点删除前关键码个数$n=\displaystyle \lceil\frac{m}{2}\rceil-1$，若这时与该结点相邻的右兄弟 (或左兄弟) 结点的关键码个数均为$$n=\displaystyle \lceil\frac{m}{2}\rceil-1$$, 则必须按以下步骤合并这两个结点。

- 若要**合并$P$中的子树指针$P_i$与$P_{i+1}$所指的结点**, 且保留$P_i$所指结点, 则把$P$中的关键码$K_{i+1}$下移到$P_i$所指的结点中。
- 把$P$中子树指针$P_{i+1}$所指结点中的全部指针和关键码都照搬到$P_i$ 所指结点的后面。删去$P_{i+1}$所指的结点。**（此时$P_i$关键码被填满）**
-  在结点$P$中用后面剩余的关键码和指针填补关键码$K_{i+1}$和指针$P_{i+1}$。**（结点前移）**
- 修改结点$P$和选定保留结点的关键码个数。

**在合并结点的过程中, 双亲结点中的关键码个数减少了。**

- 若双亲结点是根结点且结点关键码个数减到 0, 则将该双亲结点删去, **合并后保留的结点成为新的根结点**否则结束删除处理。
- 若双亲结点不是根结点且关键码个数减到$\displaystyle \lceil\frac{m}{2}\rceil-2$，又要与它自己的兄弟结点合并, 重复上面步骤。



B+树

与B树不同处：

（1）所有关键码都存放在叶结点，**上层非叶结点的关键码是其子树中最小（或最大）关键码的复写**。

（2）叶结点包含了全部关键码及指向相应数据记录存放地址的指针，且叶结点本身按关键码从小到大顺序链接。

按最大关键码复写原则组织：

（1）每个结点最多有$m$棵子树；

（2）根结点最少有1棵子树，除根结点外，其他结点至少有$\displaystyle \lceil\frac{m}{2}\rceil$棵子树；

（3）有$n$棵子树的结点有$n$个关键码；

（4）所有非叶结点可以看成是叶结点的索引，结点中关键码$K_i$与指向子树的指针$P_i$构成对子树 (即下一层索引块) 的索引项$(K_i,P_i)$，$K_i$是子树中最大的关键码。

（5）所有叶结点在同一层，按从小到大的顺序存放全部关键码，各个叶结点顺序链接。





B+树中有两个头指针：

（1）指向B+树的根结点

（2）指向关键码最小的叶结点。

可对B+树进行两种搜索运算：

（1）循叶结点自己拉起的链表顺序搜索

（2）从根开始进行自顶向下直到叶结点的随机搜索。  























