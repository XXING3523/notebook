<span style="color: orange;">**【树状数组】CF2129B **</span>

【题目大意】给定大小为$n$的排列$P=\left \{ p_1,p_2,\cdots,p_n \right \}$，对排列$A=\left \{  a_1,a_2,\cdots,a_n\right \}$，$a_i$可取$p_i$或$2n-p_i$，求$A$的一个合理构造，使$A$中逆序对数量最少。

<span style="color: orange;">**【树状数组】P1774 **</span>

【题目大意】对序列$A=\left \{  a_1,a_2,\cdots,a_n\right \} $，记交换相邻元素为一次操作，求使该序列变为不下降子序列的最小操作数。

树状数组的单点修改，单点查询，区间修改，区间查询。

树状数组对于”单点修改，区间查询“与”区间修改、单点查询“非常方便。

???success "<span style="color: orange;">**【单点修改，区间查询】LuoguP3374 树状数组1 **</span>参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e6+5;
    int n,q;
    long long t[N];
    void add(int x,int k)
    {
        while(x<=n) t[x]+=k,x+=x&(-x);
    }
    long long query(int x)
    {
        long long ans=0;
        while(x) ans+=t[x],x-=x&(-x);
        return ans;
    }
    int main()
    {
        cin>>n>>q;
        int op,x,y;
        for(int i=1;i<=n;i++)
            cin>>x,add(i,x);
        for(int i=1;i<=q;i++)
        {
            cin>>op>>x>>y;
            if(op==1) add(x,y);
            else cout<<query(y)-query(x-1)<<endl;
        }
        return 0;
    }
	```

???success "<span style="color: orange;">**【区间修改，单点查询】LuoguP3368 树状数组2 **</span>参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e6+5;
    int n,a[N],t[N],q;
    void add(int x,long long k)
    {
        while(x<=n) t[x]+=k,x+=x&(-x);
    }
    long long query(int x)
    {
        long long res=0;
        while(x) res+=t[x],x-=x&(-x);
        return res;
    }
    int main()
    {
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) add(i,a[i]-a[i-1]);
        for(int i=1;i<=q;i++)
        {
            int op,l,r,x;
            scanf("%d",&op);
            if(op==1)
            {
                scanf("%d%d%d",&l,&r,&x);
                add(l,x),add(r+1,-x);
            }
            else
            {
                scanf("%d",&x);
                printf("%d\n",query(x));
            }
        }
        return 0;
    }
	```

<span style="color: #76ee00;">**LuoguP3372 线段树1 **</span>**【题目大意】**实现区间加修改与区间和查询。

线段树的数据管理类似于二叉树。其维护的值为它的两棵子树内的所有元素做所选算子的值。

在进行修改、查询时采用了分治的思想，以区间修改、区间查询，算子为加号作为例子：在修改$[L,R]$（给区间$[L,R]$中的每个元素加$k$）时，设当前结点$node$管辖的左右区间为$L_0,R_0$，若$L\le L_0,R\ge R_0$，则对$T_{node.sum}$累加$(R_0-L_0+1)k$，并对懒标记$T_{node.lazy}累加k$

???question "为什么需要懒标记？"
	每次更新如果将和区间所有有交集的子树根节点全部更新的话，时间开销是巨大的:$O(n)$，懒标记是将更新值堆积的一种操作，在需要向儿子结点遍历时在一次性全部将之前为向下释放的更新信息合并释放，减小时间开销。举个例子，如果无懒标记，某次修改的区间包括了某子树$T$，更新的时间复杂度是$O(|T|)$,而添加懒标记会使得时间复杂度降为$O(1)$并且保留了子树的更新信息。
	

???success "<span style="color: #76ee00;">**LuoguP3372 线段树1 **</span>线段树做法"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    struct tree{int l,r;long long sum,add;}t[N*4];
    long long a[N];
    int n,q;
    void build(int p,int l,int r)
    {
        t[p].l=l,t[p].r=r;
        if(l==r){t[p].sum=a[l];return;}
        int mid=l+r>>1;
        build(2*p,l,mid),build(2*p+1,mid+1,r);
        t[p].sum=t[2*p].sum+t[2*p+1].sum;
    }
    void spread(int p)
    {
        if(t[p].add)
        {
            t[2*p].add+=t[p].add;t[2*p+1].add+=t[p].add;
            t[2*p].sum+=(t[2*p].r-t[2*p].l+1)*t[p].add;
            t[2*p+1].sum+=(t[2*p+1].r-t[2*p+1].l+1)*t[p].add;
            t[p].add=0;
        }
    }
    void change(int p,int l,int r,long long k)
    {
        if(t[p].l>=l&&t[p].r<=r)
        {
            t[p].sum+=(t[p].r-t[p].l+1)*k;
            t[p].add+=k;return;
        }
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) change(2*p,l,r,k);
        if(r>mid) change(2*p+1,l,r,k);
        t[p].sum=t[2*p].sum+t[2*p+1].sum;
    }
    long long query(int p,int l,int r)
    {
        long long res=0;
        if(t[p].l>=l&&t[p].r<=r) return t[p].sum;
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) res+=query(2*p,l,r);
        if(r>mid) res+=query(2*p+1,l,r);
        return res;
    }
    int main()
    {
        cin>>n>>q;
        for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
        build(1,1,n);
        int op,l,r;long long k;
        for(int i=1;i<=q;i++)
        {
            scanf("%d",&op);
            if(op==1)
            {
                scanf("%d%d%lld",&l,&r,&k);
                change(1,l,r,k);
            }
            else
            {
                scanf("%d%d",&l,&r);
                printf("%lld\n",query(1,l,r));
            }
        }
        return 0;
    }
	```

???success "<span style="color: #76ee00;">**LuoguP3372 线段树1 **</span>树状数组做法"



<span style="color: #76ee00;">**LuoguP3373 线段树2 **</span>**【题目大意】**实现区间加修改、区间乘修改与区间和查询。

本题需要两个懒标记$T_{node.add},T_{node.mul}$，做加法时，只需$T_{node.add}$累加$k$，但在做乘法时，需要考虑更新三个变量的值$T_{node.mul}*=k,T_{node.add}*=k$，在$spread$处，$T_{2*node/2*node+1.add}=T_{2*node/2*node+1.add}*T_{node.mul}+T_{node.add}$

因乘法同时作用于$p$处的$add$值，$2*p/2*p+1$的尚未下放的$add$值

???success "<span style="color: #76ee00;">**LuoguP3373 线段树2 **</span>参考实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    struct tree{int l,r;long long sum,add,mul;}t[N*4];
    long long a[N],mod;
    int n,q;
    void build(int p,int l,int r)
    {
        t[p].l=l,t[p].r=r,t[p].mul=1;
        if(l==r){t[p].sum=a[l]%mod;return;}
        int mid=l+r>>1;
        build(2*p,l,mid),build(2*p+1,mid+1,r);
        t[p].sum=(t[2*p].sum+t[2*p+1].sum)%mod;
    }
    void spread(int p)
    {
        if(t[p].add||t[p].mul!=1)
        {
            t[2*p].add=t[2*p].add*t[p].mul%mod;
            t[2*p+1].add=t[2*p+1].add*t[p].mul%mod;
            t[2*p].add=(t[2*p].add+t[p].add)%mod;
            t[2*p+1].add=(t[2*p+1].add+t[p].add)%mod;
            t[2*p].mul=t[2*p].mul*t[p].mul%mod;
            t[2*p+1].mul=t[2*p+1].mul*t[p].mul%mod;
            t[2*p].sum=(t[2*p].sum*t[p].mul%mod+(t[2*p].r-t[2*p].l+1)*t[p].add)%mod;
            t[2*p+1].sum=(t[2*p+1].sum*t[p].mul%mod+(t[2*p+1].r-t[2*p+1].l+1)*t[p].add)%mod;
            t[p].add=0,t[p].mul=1;
        }
    }
    void mul(int p,int l,int r,long long k)
    {
        if(t[p].l>=l&&t[p].r<=r)
        {
            t[p].sum=t[p].sum*k%mod;
            t[p].mul=t[p].mul*k%mod;
            t[p].add=t[p].add*k%mod;return;
        }
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) mul(2*p,l,r,k);
        if(r>mid) mul(2*p+1,l,r,k);
        t[p].sum=(t[2*p].sum+t[2*p+1].sum)%mod;
    }
    void add(int p,int l,int r,long long k)
    {
        if(t[p].l>=l&&t[p].r<=r)
        {
            t[p].sum=(t[p].sum+(t[p].r-t[p].l+1)*k)%mod;
            t[p].add=(t[p].add+k)%mod;return;
        }
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) add(2*p,l,r,k);
        if(r>mid) add(2*p+1,l,r,k);
        t[p].sum=(t[2*p].sum+t[2*p+1].sum)%mod;
    }
    long long query(int p,int l,int r)
    {
        long long res=0;
        if(t[p].l>=l&&t[p].r<=r) 
            return t[p].sum%mod;
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) res=(res+query(2*p,l,r))%mod;
        if(r>mid) res=(res+query(2*p+1,l,r))%mod;
        return res;
    }
    int main()
    {
        cin>>n>>q>>mod;
        for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
        build(1,1,n);
        int op,l,r;long long k;
        for(int i=1;i<=q;i++)
        {
            scanf("%d",&op);
            if(op==1)
            {
                scanf("%d%d%lld",&l,&r,&k);
                mul(1,l,r,k);
            }
            else if(op==2)
            {
                scanf("%d%d%lld",&l,&r,&k);
                add(1,l,r,k);
            }
            else
            {
                scanf("%d%d",&l,&r);
                printf("%lld\n",query(1,l,r));
            }
        }
        return 0;
    }
	```

<span style="color: #7ec0ee;">**【平衡树】LuoguP6136 普通平衡树（数据加强版）**</span>

**【题目大意】**实现一种数据结构来维护可重集合$M$，需要提供以下操作：

（1）向$M$中插入数$x$

（2）从$M$中删除一个数$x$（若有多个相同的数，应只删除一个）

（3）查询M中有多少个数比$x$小，并将得到的答案加1（$x$可能不存在于$M$中）

（4）查询如果将$M$从小到大排列后，排名位于第$x$位的数

（5）求$M$中$x$的前驱（$x$可能不存在于$M$中）

（6）求$M$中$x$的后继（$x$可能不存在于$M$中）

??? "Splay树写法"
    Splay（伸展树）是一种平衡二叉树，通过不断将某个结点旋转到根节点，使整棵树仍然满足BST的性质且保持平衡，由Daniel Sleator和Robert Tarjan发明。
	

	**Splay使得每次操作的均摊复杂度为$O(\log n)$**
	
	???success "均摊时间复杂度$O(\log n)$的证明"
	
	每个节点$node$的信息包括：$s_0,s_1$分别指示左右儿子，$p$指示祖先。$cnt$指示当前结点权值出现次数。
	
	???info "左旋，右旋的统一写法和pushup"
	    ```
	    void rotate(int x)
	    {
	        int y=tr[x].p,z=tr[y].p;
	        int k=tr[y].s[1]==x;
	        tr[y].s[k]=tr[x].s[k^1];
	        tr[tr[x].s[k^1]].p=y;
	        tr[x].s[k^1]=y;
	        tr[y].p=x;
	        tr[z].s[tr[z].s[1]==y]=x;
	        tr[x].p=z;
	        pushup(y),pushup(x);
	    }
	    ```
	    设链$z\to y\to x$要进行左旋或右旋，则$x$为$y$的左儿子还是右儿子决定了左旋还是右旋。
	    
	    pushup用于更新子树总结点个数。
	    ```
	    void pushup(int x)
	    {
	         tr[x].size=tr[tr[x].s[0]].size+tr[tr[x].s[1]].size+tr[x].cnt;
	    }
	    ```
	
	???info "Splay实现"
		伸展（Splay）：访问一个结点$x$，并把$x$旋转到根节点。
		
	    将$x$转到$k$的下方，若$k=0$，则将$x$转到$root$
	    ```
	    void splay(int x,int k)
	    {
	        while(tr[x].p!=k)
	        {
	            int y=tr[x].p,z=tr[y].p;
	            if(z!=k)
	                (tr[y].s[0]==x)^(tr[z].s[0]==y)?rotate(x):rotate(y);
	            rotate(x);
	        }
	        if(k==0) root=x;
	    }
	    ```
	
	???info "find查找的实现"
	    找到$v$所在结点，并把该节点转到根。
	    ```
	    void find(int v)
	    {
	        int x=root;
	        while(tr[x].s[v>tr[x].v]&&v!=tr[x].v)
	            x=tr[x].s[v>tr[x].v];
	        splay(x,0);
	    }
	    ```
	
	???info "getpre查找前驱、getsuc查找后继的实现"
	    ```
	    int get_pre(int v)
	    {
	        find(v);
	        int x=root;//此时权值为v/接近v的结点已经被转到根节点
	        if(tr[x].v<v) return x;
	        x=tr[x].s[0];
	        while(tr[x].s[1]) x=tr[x].s[1];
	        splay(x,0);return x;
	    }
	    int get_suc(int v)
	    {	
	        find(v);
	        int x=root;
	        if(tr[x].v>v) return x;
	        x=tr[x].s[1];
	        while(tr[x].s[0]) x=tr[x].s[0];
	        splay(x,0);return x;
	    }
	    ```
	
	???info "del删除结点，insert插入节点"
	    ```
	    void del(int v)
	    {
	        int pre=get_pre(v),suc=get_suc(v);
	        splay(pre,0);splay(suc,pre);
	        int del=tr[suc].s[0];
	        if(tr[del].cnt>1) tr[del].cnt--,splay(del,0);
	        else tr[suc].s[0]=0,splay(suc,0);
	    }
	    void insert(int v)
	    {
	        int x=root,p=0;
	        while(x&&tr[x].v!=v)
	            p=x,x=tr[x].s[v>tr[x].v];
	        if(x) tr[x].cnt++;
	        else
	        {
	            x=++idx;
	            tr[p].s[v>tr[p].v]=x;
	            tr[x].init(p,v);
	        }
	        splay(x,0);
	    }
	    ```
	
	???info "getrank查询排名，getval根据排名查询数值"
	    ```
	    int get_rank(int v)
	    {
	        insert(v);
	        int res=tr[tr[root].s[0]].size;
	        del(v);return res;
	    }
	    int get_val(int p)
	    {
	        int x=root;
	        while(1)
	        {
	            int y=tr[x].s[0];
	            if(tr[y].size+tr[x].cnt<p)
	            {
	                p-=tr[y].size+tr[x].cnt;
	                x=tr[x].s[1];
	            }
	            else
	            {
	                if(tr[y].size>=p) x=tr[x].s[0];
	                else break;
	            }
	        }
	        splay(x,0);
	        return tr[x].v;
	    }
	    ```


    ???success "Splay参考代码，以<span style="color: #7ec0ee;">**LuoguP6136 普通平衡树（数据加强版）**</span>为例"
        ```
        #include<bits/stdc++.h>
        using namespace std;
        const int N=1e6+5,INF=2147483647;
        int q,root,idx,n;
        struct node
        {int s[2],p,v,cnt,size;
        void init(int p1,int v1)
        {p=p1,v=v1,cnt=size=1;}}tr[N*4];
        void pushup(int x)
        {
            tr[x].size=tr[tr[x].s[0]].size+
            tr[tr[x].s[1]].size+tr[x].cnt;
        }
        void rotate(int x)
        {
            int y=tr[x].p,z=tr[y].p;
            int k=tr[y].s[1]==x;
            tr[y].s[k]=tr[x].s[k^1];
            tr[tr[x].s[k^1]].p=y;
            tr[x].s[k^1]=y;
            tr[y].p=x;
            tr[x].p=z;
            tr[z].s[tr[z].s[1]==y]=x;
            pushup(y),pushup(x);
        }
        void splay(int x,int k)
        {
            while(tr[x].p!=k)
            {
                int y=tr[x].p,z=tr[y].p;
                if(z!=k)
                    (tr[z].s[0]==y)^(tr[y].s[0]==x)?
                    rotate(x):rotate(y);
                rotate(x);
            }
            if(k==0) root=x;
        }
        void find(int v)
        {
            int x=root;
            while(tr[x].s[v>tr[x].v]&&tr[x].v!=v)
                x=tr[x].s[v>tr[x].v];
            splay(x,0);
        }
        int get_pre(int v)
        {
            find(v);int x=root;
            if(tr[x].v<v) return x;
            x=tr[x].s[0];
            while(tr[x].s[1]) x=tr[x].s[1];
            splay(x,0);return x;
        }
        int get_suc(int v)
        {
            find(v);int x=root;
            if(tr[x].v>v) return x;
            x=tr[x].s[1];
            while(tr[x].s[0]) x=tr[x].s[0];
            splay(x,0);return x;
        }
        void insert(int v)
        {
            int x=root,p=0;
            while(x&&tr[x].v!=v)
                p=x,x=tr[x].s[v>tr[x].v];
            if(x) tr[x].cnt++;
            else
            {
                x=++idx;
                tr[p].s[v>tr[p].v]=x;
                tr[x].init(p,v);
            }
            splay(x,0);
        }
        void del(int v)
        {
            int pre=get_pre(v),suc=get_suc(v);
            splay(pre,0);splay(suc,pre);
            int del=tr[suc].s[0];
            if(tr[del].cnt>1) tr[del].cnt--,splay(del,0);
            else tr[suc].s[0]=0,splay(suc,0);
        }
        int get_rank(int v)
        {
            insert(v);
            int res=tr[tr[root].s[0]].size;
            del(v);return res;
        }
        int get_val(int p)
        {
            int x=root;
            while(1)
            {
                int y=tr[x].s[0];
                if(tr[y].size+tr[x].cnt<p)
                {
                    p-=tr[y].size+tr[x].cnt;
                    x=tr[x].s[1];
                }
                else
                {
                    if(tr[y].size>=p) x=tr[x].s[0];
                    else break;
                }
            }
            splay(x,0);
            return tr[x].v;
        }
        int main()
        {
            insert(-INF),insert(INF);
            cin>>n>>q;int op,x,last=0,ans=0;
            for(int i=1;i<=n;i++)
                scanf("%d",&x),insert(x);
            for(int i=1;i<=q;i++)
            {
                scanf("%d%d",&op,&x);
                if(op==1) insert(x^last);
                else if(op==2) del(x^last);
                else
                {
                    if(op==3) last=get_rank(x^last);
                    else if(op==4) last=get_val((x^last)+1);
                    else if(op==5) last=tr[get_pre(x^last)].v;
                    else last=tr[get_suc(x^last)].v;
                    ans^=last; 
                }
            }
            cout<<ans;
        }
        ```

??? "Treap写法"
	
	!!!info "单次操作的期望时间复杂度优化为$O(\log n)$"
		
		随机优先级使得Treap的形状等价于“随机二叉搜索树”，后者的期望高度为$O(\log n)$
		
		同时满足BST和heap性质的树是唯一的，heap确定了BST的插入顺序。
		
		???success "相关证明"
		
			按键值大小排序为$1,2,\cdots,n$，第$i$个键的深度为$depth_i$，对每个$j\neq i$定义指示变量$A_j=1$当且仅当$j$是$i$的祖先。则$\displaystyle D_i=\sum_\limits{j\neq i}A_j$，故$\displaystyle ED_i=\sum_\limits{j\neq i}A_j$
		
			对任意区间$[a,b],i\in [a,b]$，区间内优先级最高的结点会成为这个区间对应子树的根，对于$j<i$，结点$j$成为$i$的祖先当且仅当区间$[j,i]$中$j$的键值最大，概率为$\displaystyle \frac{1}{j-i+1}$
		
			故$\displaystyle ED_i=\sum_\limits{j\neq i}A_j=\sum_{k=1}^{i-1}\frac{1}{k-i+1}+\sum_{k=i+1}^{n}\frac{1}{k-i+1}=H_{i}+H_{n-i+1}-2$，其中$H_m$是第$m$个调和数，$\displaystyle H_m=\sum_{t=1}^{m}\frac{1}{t}=\ln m+\gamma$
		
			故$ED_i=O(\log n)$对任意$i$成立，树高度的期望为$O(\log n)$


​	
	???success "Treap参考代码，以<span style="color: #7ec0ee;">**LuoguP6136 普通平衡树（数据加强版）**</span>为例"
	    ```
	    #include<bits/stdc++.h>
	    using namespace std;
	    const int N=1e6+5,INF=2147483647;
	    int q,idx,root=0,n;
	    struct node
	    {
	        int s[2],size,cnt,rd,v;
	        void init(int v1)
	        {v=v1,cnt=size=1,rd=rand();}
	    }tr[N*4];
	    void pushup(int p)
	    {
	        tr[p].size=tr[tr[p].s[0]].size+tr[tr[p].s[1]].size+tr[p].cnt;
	    }
	    void rotate(int &p,int d)
	    {
	        int k=tr[p].s[d^1];
	        tr[p].s[d^1]=tr[k].s[d];
	        tr[k].s[d]=p;
	        pushup(p),pushup(k);p=k;
	    }
	    void insert(int &p,int x)
	    {
	        if(!p)
	        {
	            p=++idx,tr[p].init(x);return;
	        } 
	        if(tr[p].v==x)
	        {
	            tr[p].cnt++,tr[p].size++;
	            return;
	        }
	        int d=x>tr[p].v;
	        insert(tr[p].s[d],x);
	        if(tr[p].rd<tr[tr[p].s[d]].rd) rotate(p,d^1);
	        pushup(p);
	    }
	    void del(int &p,int x)
	    {
	        if(!p) return;
	        if(x<tr[p].v) del(tr[p].s[0],x);
	        else if(x>tr[p].v) del(tr[p].s[1],x);
	        else
	        {
	            if(!tr[p].s[0]&&!tr[p].s[1])
	            {
	                tr[p].cnt--,tr[p].size--;
	                if(tr[p].cnt==0) p=0;
	            }
	            else if(tr[p].s[0]&&!tr[p].s[1])
	            {
	                rotate(p,1);
	                del(tr[p].s[1],x);
	            }
	            else if(!tr[p].s[0]&&tr[p].s[1])
	            {
	                rotate(p,0);
	                del(tr[p].s[0],x);
	            }
	            else
	            {
	                int d=tr[tr[p].s[0]].rd>tr[tr[p].s[1]].rd;
	                rotate(p,d);
	                del(tr[p].s[d],x);
	            }
	        }
	        pushup(p);
	    }
	    int getrank(int p,int x)
	    {
	        if(!p) return 1;
	        if(tr[p].v==x) return tr[tr[p].s[0]].size+1;
	        if(tr[p].v<x) return tr[tr[p].s[0]].size+
	        tr[p].cnt+getrank(tr[p].s[1],x);
	        if(tr[p].v>x) return getrank(tr[p].s[0],x);
	    }
	    int getval(int p,int x)
	    {
	        if(!p) return 0;
	        if(tr[tr[p].s[0]].size>=x) return getval(tr[p].s[0],x);
	        else if(tr[tr[p].s[0]].size+tr[p].cnt<x) 
	            return getval(tr[p].s[1],x-tr[tr[p].s[0]].size-tr[p].cnt);
	        else return tr[p].v; 
	    }
	    int get_pre(int p,int x)
	    {
	        if(!p) return -INF;
	        if(tr[p].v>=x) return get_pre(tr[p].s[0],x);
	        else return max(tr[p].v,get_pre(tr[p].s[1],x));
	    }
	    int get_suc(int p,int x)
	    {
	        if(!p) return INF;
	        if(tr[p].v<=x) return get_suc(tr[p].s[1],x);
	        else return min(tr[p].v,get_suc(tr[p].s[0],x));
	    }
	    int main()
	    {
	        int op,x,last=0,ans=0;
	        cin>>n>>q;
	        for(int i=1;i<=n;i++) 
	            scanf("%d",&x),insert(root,x);
	        for(int i=1;i<=q;i++)
	        {
	            scanf("%d%d",&op,&x);
	            x=x^last;
	            if(op==1) insert(root,x);
	            if(op==2) del(root,x);
	            if(op==3) last=getrank(root,x),ans^=last;
	            if(op==4) last=getval(root,x),ans^=last;
	            if(op==5) last=get_pre(root,x),ans^=last;
	            if(op==6) last=get_suc(root,x),ans^=last;
	        }
	        cout<<ans;
	        return 0;
	    }
	    ```
