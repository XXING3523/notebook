<span style="color: orange;">**【树状数组】CF2129B **</span>

【题目大意】给定大小为$n$的排列$P=\left \{ p_1,p_2,\cdots,p_n \right \}$，对排列$A=\left \{  a_1,a_2,\cdots,a_n\right \}$，$a_i$可取$p_i$或$2n-p_i$，求$A$的一个合理构造，使$A$中逆序对数量最少。

<span style="color: orange;">**【树状数组】P1774 **</span>

【题目大意】对序列$A=\left \{  a_1,a_2,\cdots,a_n\right \} $，记交换相邻元素为一次操作，求使该序列变为不下降子序列的最小操作数。

树状数组的单点修改，单点查询，区间修改，区间查询。

树状数组对于”单点修改，区间查询“与”区间修改、单点查询“非常方便。

???success "<span style="color: orange;">**【单点修改，区间查询】LuoguP3374 树状数组1 **</span>参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e6+5;
    int n,q;
    long long t[N];
    void add(int x,int k)
    {
        while(x<=n) t[x]+=k,x+=x&(-x);
    }
    long long query(int x)
    {
        long long ans=0;
        while(x) ans+=t[x],x-=x&(-x);
        return ans;
    }
    int main()
    {
        cin>>n>>q;
        int op,x,y;
        for(int i=1;i<=n;i++)
            cin>>x,add(i,x);
        for(int i=1;i<=q;i++)
        {
            cin>>op>>x>>y;
            if(op==1) add(x,y);
            else cout<<query(y)-query(x-1)<<endl;
        }
        return 0;
    }
	```

???success "<span style="color: orange;">**【区间修改，单点查询】LuoguP3368 树状数组2 **</span>参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e6+5;
    int n,a[N],t[N],q;
    void add(int x,long long k)
    {
        while(x<=n) t[x]+=k,x+=x&(-x);
    }
    long long query(int x)
    {
        long long res=0;
        while(x) res+=t[x],x-=x&(-x);
        return res;
    }
    int main()
    {
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) add(i,a[i]-a[i-1]);
        for(int i=1;i<=q;i++)
        {
            int op,l,r,x;
            scanf("%d",&op);
            if(op==1)
            {
                scanf("%d%d%d",&l,&r,&x);
                add(l,x),add(r+1,-x);
            }
            else
            {
                scanf("%d",&x);
                printf("%d\n",query(x));
            }
        }
        return 0;
    }
	```

<span style="color: #76ee00;">**LuoguP3372 线段树1 **</span>**【题目大意】**实现区间加修改与区间和查询。

线段树的数据管理类似于二叉树。其维护的值为它的两棵子树内的所有元素做所选算子的值。

在进行修改、查询时采用了分治的思想，以区间修改、区间查询，算子为加号作为例子：在修改$[L,R]$（给区间$[L,R]$中的每个元素加$k$）时，设当前结点$node$管辖的左右区间为$L_0,R_0$，若$L\le L_0,R\ge R_0$，则对$T_{node.sum}$累加$(R_0-L_0+1)k$，并对懒标记$T_{node.lazy}累加k$

???question "为什么需要懒标记？"
	每次更新如果将和区间所有有交集的子树根节点全部更新的话，时间开销是巨大的:$O(n)$，懒标记是将更新值堆积的一种操作，在需要向儿子结点遍历时在一次性全部将之前为向下释放的更新信息合并释放，减小时间开销。举个例子，如果无懒标记，某次修改的区间包括了某子树$T$，更新的时间复杂度是$O(|T|)$,而添加懒标记会使得时间复杂度降为$O(1)$并且保留了子树的更新信息。
	

???success "<span style="color: #76ee00;">**LuoguP3372 线段树1 **</span>线段树做法"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    struct tree{int l,r;long long sum,add;}t[N*4];
    long long a[N];
    int n,q;
    void build(int p,int l,int r)
    {
        t[p].l=l,t[p].r=r;
        if(l==r){t[p].sum=a[l];return;}
        int mid=l+r>>1;
        build(2*p,l,mid),build(2*p+1,mid+1,r);
        t[p].sum=t[2*p].sum+t[2*p+1].sum;
    }
    void spread(int p)
    {
        if(t[p].add)
        {
            t[2*p].add+=t[p].add;t[2*p+1].add+=t[p].add;
            t[2*p].sum+=(t[2*p].r-t[2*p].l+1)*t[p].add;
            t[2*p+1].sum+=(t[2*p+1].r-t[2*p+1].l+1)*t[p].add;
            t[p].add=0;
        }
    }
    void change(int p,int l,int r,long long k)
    {
        if(t[p].l>=l&&t[p].r<=r)
        {
            t[p].sum+=(t[p].r-t[p].l+1)*k;
            t[p].add+=k;return;
        }
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) change(2*p,l,r,k);
        if(r>mid) change(2*p+1,l,r,k);
        t[p].sum=t[2*p].sum+t[2*p+1].sum;
    }
    long long query(int p,int l,int r)
    {
        long long res=0;
        if(t[p].l>=l&&t[p].r<=r) return t[p].sum;
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) res+=query(2*p,l,r);
        if(r>mid) res+=query(2*p+1,l,r);
        return res;
    }
    int main()
    {
        cin>>n>>q;
        for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
        build(1,1,n);
        int op,l,r;long long k;
        for(int i=1;i<=q;i++)
        {
            scanf("%d",&op);
            if(op==1)
            {
                scanf("%d%d%lld",&l,&r,&k);
                change(1,l,r,k);
            }
            else
            {
                scanf("%d%d",&l,&r);
                printf("%lld\n",query(1,l,r));
            }
        }
        return 0;
    }
	```

???success "<span style="color: #76ee00;">**LuoguP3372 线段树1 **</span>树状数组做法"



<span style="color: #76ee00;">**LuoguP3373 线段树2 **</span>**【题目大意】**实现区间加修改、区间乘修改与区间和查询。

本题需要两个懒标记$T_{node.add},T_{node.mul}$，做加法时，只需$T_{node.add}$累加$k$，但在做乘法时，需要考虑更新三个变量的值$T_{node.mul}*=k,T_{node.add}*=k$，在$spread$处，$T_{2*node/2*node+1.add}=T_{2*node/2*node+1.add}*T_{node.mul}+T_{node.add}$

因乘法同时作用于$p$处的$add$值，$2*p/2*p+1$的尚未下放的$add$值

???success "<span style="color: #76ee00;">**LuoguP3373 线段树2 **</span>参考实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    struct tree{int l,r;long long sum,add,mul;}t[N*4];
    long long a[N],mod;
    int n,q;
    void build(int p,int l,int r)
    {
        t[p].l=l,t[p].r=r,t[p].mul=1;
        if(l==r){t[p].sum=a[l]%mod;return;}
        int mid=l+r>>1;
        build(2*p,l,mid),build(2*p+1,mid+1,r);
        t[p].sum=(t[2*p].sum+t[2*p+1].sum)%mod;
    }
    void spread(int p)
    {
        if(t[p].add||t[p].mul!=1)
        {
            t[2*p].add=t[2*p].add*t[p].mul%mod;
            t[2*p+1].add=t[2*p+1].add*t[p].mul%mod;
            t[2*p].add=(t[2*p].add+t[p].add)%mod;
            t[2*p+1].add=(t[2*p+1].add+t[p].add)%mod;
            t[2*p].mul=t[2*p].mul*t[p].mul%mod;
            t[2*p+1].mul=t[2*p+1].mul*t[p].mul%mod;
            t[2*p].sum=(t[2*p].sum*t[p].mul%mod+(t[2*p].r-t[2*p].l+1)*t[p].add)%mod;
            t[2*p+1].sum=(t[2*p+1].sum*t[p].mul%mod+(t[2*p+1].r-t[2*p+1].l+1)*t[p].add)%mod;
            t[p].add=0,t[p].mul=1;
        }
    }
    void mul(int p,int l,int r,long long k)
    {
        if(t[p].l>=l&&t[p].r<=r)
        {
            t[p].sum=t[p].sum*k%mod;
            t[p].mul=t[p].mul*k%mod;
            t[p].add=t[p].add*k%mod;return;
        }
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) mul(2*p,l,r,k);
        if(r>mid) mul(2*p+1,l,r,k);
        t[p].sum=(t[2*p].sum+t[2*p+1].sum)%mod;
    }
    void add(int p,int l,int r,long long k)
    {
        if(t[p].l>=l&&t[p].r<=r)
        {
            t[p].sum=(t[p].sum+(t[p].r-t[p].l+1)*k)%mod;
            t[p].add=(t[p].add+k)%mod;return;
        }
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) add(2*p,l,r,k);
        if(r>mid) add(2*p+1,l,r,k);
        t[p].sum=(t[2*p].sum+t[2*p+1].sum)%mod;
    }
    long long query(int p,int l,int r)
    {
        long long res=0;
        if(t[p].l>=l&&t[p].r<=r) 
            return t[p].sum%mod;
        spread(p);
        int mid=t[p].l+t[p].r>>1;
        if(l<=mid) res=(res+query(2*p,l,r))%mod;
        if(r>mid) res=(res+query(2*p+1,l,r))%mod;
        return res;
    }
    int main()
    {
        cin>>n>>q>>mod;
        for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
        build(1,1,n);
        int op,l,r;long long k;
        for(int i=1;i<=q;i++)
        {
            scanf("%d",&op);
            if(op==1)
            {
                scanf("%d%d%lld",&l,&r,&k);
                mul(1,l,r,k);
            }
            else if(op==2)
            {
                scanf("%d%d%lld",&l,&r,&k);
                add(1,l,r,k);
            }
            else
            {
                scanf("%d%d",&l,&r);
                printf("%lld\n",query(1,l,r));
            }
        }
        return 0;
    }
	```

