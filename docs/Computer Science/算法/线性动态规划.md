线性动态规划

<span style="color: orange;">**P2285 打鼹鼠**</span>

**【题目大意】**$n \times n$ 网格中，某些时刻鼹鼠会在某一个网格出现。你可控制一个机器人打鼹鼠，若 $i$ 时刻鼹鼠在某网格中出现，而机器人也处于同一网格，则此鼹鼠可被杀死。

机器人每一时刻只能像相邻位置移动一格或原地不动，即 $(i, j)$ 网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 网格，机器人不能走出整个 $n \times n$ 网格。

你可自由选定机器人的初始位置。

现在知道$m$只鼹鼠出现的时间$t_i$（按不降序给出）和地点$(x_i,y_i)$，求杀死鼹鼠最大值。（注：同一地点在同一时刻仅会出现最多1只鼹鼠）

记$dp_i$为处理完第$i$只鼹鼠后的杀死数最大值。

$$dp_i=\max(1,\max\limits _{|x_i-x_j|+|y_i-y_j|\le t_i-t_j}^{1\le j<i}dp_j+1)$$

最终结果为$\max\limits_{1\le i\le n}dp_i$

<span style="color:#76ee00 ;">**【单调队列优化】LuoguP1725 琪露诺**</span>

**【题目大意】**对于序列$A=\left \{ a_0, a_1,a_2,\cdots,a_n\right \},a_0=0$，从0下标出发，当位于$i$下标时，可以跳跃到$[i+L,i+R]$下标处并收集到达点的点数$a_k$，求最终跳出序列，即$i>n$时收集点数和的最大值。

设$dp_i$表示到达下标$i$时，收集点数的最大值，有：

$$dp_i=\max\limits _{i-R\le j\le i-L}dp_j+a_i$$

需要使用单调队列维护区间$dp_{max}$，算法时间复杂度为$O(n)$

???success "参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=2e5+5;
    int a[N];
    int q[N],len,head=1,tail=0,dp[N],n,l,r,ans=-1e9;
    void add(int x)
    {
        while(dp[q[tail]]<=dp[x]&&head<=tail) 
            tail--;
        q[++tail]=x;
        while(q[head]<=x-len) head++;
    }
    int main()
    {
        scanf("%d%d%d",&n,&l,&r);
        len=r-l+1;
        for(int i=0;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) dp[i]=-1e9;
        for(int i=l;i<=n;i++)
        {
            add(i-l);
            dp[i]=dp[q[head]]+a[i];
        }
        for(int i=n-r+1;i<=n;i++)
            ans=max(dp[i],ans);
        printf("%d",ans);
        return 0;
    }
	```



<span style="color:#76ee00 ;">**【树状数组优化】【二分优化】LuoguP1439 两个排列的最长公共子序列**</span>

【题目大意】给出$1,2,\cdots,n$的两个排列$P_1,P_2$，求它们的最长公共子序列。

???success "<span style="color:#76ee00 ;">**LuoguP1439 两个排列的最长公共子序列**</span>二分优化实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    int dp[N],f[N],ans,n,a[N],b[N],c[N];
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++) f[i]=1e9;
        for(int i=1;i<=n;i++) 
            scanf("%d",&a[i]),c[a[i]]=i;
        for(int i=1;i<=n;i++)
            scanf("%d",&b[i]),b[i]=c[b[i]];
        for(int i=1;i<=n;i++)
        {
            if(b[i]<f[1]) dp[i]=1,f[1]=min(f[1],b[i]);
            else
            {
                int num=lower_bound(f+1,f+n+1,b[i])-f-1;
                dp[i]=num+1;
                f[dp[i]]=min(f[dp[i]],b[i]);
            }
            ans=max(ans,dp[i]);
        }
        cout<<ans;
        return 0;
    }
	```



???success "<span style="color:#76ee00 ;">**LuoguP1439 两个排列的最长公共子序列**</span>树状数组实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    int t[4*N],n,a[N],b[N],c[N],ans,dp[N];
    void add(int x,int k)
    {while(x<=n) t[x]=max(t[x],k),x+=x&(-x);}
    int query(int x)
    {
        int res=0;
        while(x) res=max(res,t[x]),x-=x&(-x); 
        return res;
    }
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++) 
            scanf("%d",&a[i]),c[a[i]]=i;
        for(int i=1;i<=n;i++)
            scanf("%d",&b[i]),b[i]=c[b[i]];
        for(int i=1;i<=n;i++)
        {
            int cur=query(b[i]-1);
            if(!cur) dp[i]=1;
            else dp[i]=cur+1;
            add(b[i],dp[i]);
            ans=max(ans,dp[i]);
        }
        cout<<ans;
        return 0;
    }
	```
