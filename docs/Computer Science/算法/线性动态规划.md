线性动态规划

<span style="color: orange;">**LuoguP2285 打鼹鼠**</span>

**【题目大意】**$n \times n$ 网格中，某些时刻鼹鼠会在某一个网格出现。你可控制一个机器人打鼹鼠，若 $i$ 时刻鼹鼠在某网格中出现，而机器人也处于同一网格，则此鼹鼠可被杀死。

机器人每一时刻只能像相邻位置移动一格或原地不动，即 $(i, j)$ 网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 网格，机器人不能走出整个 $n \times n$ 网格。

你可自由选定机器人的初始位置。

现在知道$m$只鼹鼠出现的时间$t_i$（按不降序给出）和地点$(x_i,y_i)$，求杀死鼹鼠最大值。（注：同一地点在同一时刻仅会出现最多1只鼹鼠）

记$dp_i$为处理完第$i$只鼹鼠后的杀死数最大值。

$$dp_i=\max(1,\max\limits _{|x_i-x_j|+|y_i-y_j|\le t_i-t_j}^{1\le j<i}dp_j+1)$$

最终结果为$\max\limits_{1\le i\le n}dp_i$

<span style="color:#76ee00 ;">**【单调队列优化】LuoguP1725 琪露诺**</span>

**【题目大意】**对于序列$A=\left \{ a_0, a_1,a_2,\cdots,a_n\right \},a_0=0$，从0下标出发，当位于$i$下标时，可以跳跃到$[i+L,i+R]$下标处并收集到达点的点数$a_k$，求最终跳出序列，即$i>n$时收集点数和的最大值。

设$dp_i$表示到达下标$i$时，收集点数的最大值，有：

$$dp_i=\max\limits _{i-R\le j\le i-L}dp_j+a_i$$

需要使用单调队列维护区间$dp_{max}$，算法时间复杂度为$O(n)$

???success "参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=2e5+5;
    int a[N];
    int q[N],len,head=1,tail=0,dp[N],n,l,r,ans=-1e9;
    void add(int x)
    {
        while(dp[q[tail]]<=dp[x]&&head<=tail) 
            tail--;
        q[++tail]=x;
        while(q[head]<=x-len) head++;
    }
    int main()
    {
        scanf("%d%d%d",&n,&l,&r);
        len=r-l+1;
        for(int i=0;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) dp[i]=-1e9;
        for(int i=l;i<=n;i++)
        {
            add(i-l);
            dp[i]=dp[q[head]]+a[i];
        }
        for(int i=n-r+1;i<=n;i++)
            ans=max(dp[i],ans);
        printf("%d",ans);
        return 0;
    }
	```



<span style="color:#76ee00 ;">**【树状数组优化】【二分优化】LuoguP1439 两个排列的最长公共子序列**</span>

【题目大意】给出$1,2,\cdots,n$的两个排列$P_1,P_2$，求它们的最长公共子序列。

???success "<span style="color:#76ee00 ;">**LuoguP1439 两个排列的最长公共子序列**</span>二分优化实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    int dp[N],f[N],ans,n,a[N],b[N],c[N];
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++) f[i]=1e9;
        for(int i=1;i<=n;i++) 
            scanf("%d",&a[i]),c[a[i]]=i;
        for(int i=1;i<=n;i++)
            scanf("%d",&b[i]),b[i]=c[b[i]];
        for(int i=1;i<=n;i++)
        {
            if(b[i]<f[1]) dp[i]=1,f[1]=min(f[1],b[i]);
            else
            {
                int num=lower_bound(f+1,f+n+1,b[i])-f-1;
                dp[i]=num+1;
                f[dp[i]]=min(f[dp[i]],b[i]);
            }
            ans=max(ans,dp[i]);
        }
        cout<<ans;
        return 0;
    }
	```



???success "<span style="color:#76ee00 ;">**LuoguP1439 两个排列的最长公共子序列**</span>树状数组实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    int t[4*N],n,a[N],b[N],c[N],ans,dp[N];
    void add(int x,int k)
    {while(x<=n) t[x]=max(t[x],k),x+=x&(-x);}
    int query(int x)
    {
        int res=0;
        while(x) res=max(res,t[x]),x-=x&(-x); 
        return res;
    }
    int main()
    {
        cin>>n;
        for(int i=1;i<=n;i++) 
            scanf("%d",&a[i]),c[a[i]]=i;
        for(int i=1;i<=n;i++)
            scanf("%d",&b[i]),b[i]=c[b[i]];
        for(int i=1;i<=n;i++)
        {
            int cur=query(b[i]-1);
            if(!cur) dp[i]=1;
            else dp[i]=cur+1;
            add(b[i],dp[i]);
            ans=max(ans,dp[i]);
        }
        cout<<ans;
        return 0;
    }
	```

**【相关习题】**<span style="color: orange;">**LuoguP1091 合唱队形**</span>

<span style="color: #76ee00;">**【二分优化】【序】LuoguP1020 导弹拦截**</span>

**【题目大意】**求序列$A$的最长不递增子序列长度与将$A$划分为若干不交的不递增子序列的最小划分数。

???info "Dilworth定理"
	引理：Dilworth定理：对有限偏序集$S$和其上的偏序$\preceq$，$S$的宽度（最长反链$L$长度）等于最小的链覆盖数。
	???success "证明1"
		数学归纳法：记链覆盖集合为$T$，当$|S|\le 3$时，命题显然成立。当$|S|=p$时，假设$|S|<p$的所有情况均满足命题，可以记向某个$S'(S'\subset S,|S'|=p-1)$中插入元素$e$，得到$S$。

		（1）若插入$e$使得反链长度增加1，则对于原反链序列$L=\left \{  l_1,l_2,\cdots,l_{|L|}\right \}$，$\exists t_i,t_{i+1}\in T,t_i\succeq e\succeq t_{i_1}$，可以证明$|T|\ge $$|L|+1$，而对于链覆盖的划分，可以在$S'$的基础上给$e$单独划一条链，$|T|\le|L|+1$，故$|T|=|L|+1$。
	
		（2）若插入使得反链长度不增加，则一定有（1）不成立，必然存在链上一点$l_i$，
	
	???success "证明2"
		数学归纳法：当$|S|\le 3$时，成立。
		
		设命题对所有元素个数小于$|S|$的偏序集均成立，令$S$的宽度为$d$，若$S$中所有元素均不可比，命题显然成立，否则在$S$中取一条长度大于1的链，令其最小元为$m$，最大元为$M$。
		
		令$T=S-\left \{  m,M \right \}$，若$T$中的宽度不超过$d-1$，由归纳假设知$T$可被至多$d-1$条链覆盖，进而可被这些链加上链$\left \{  m,M \right \}$覆盖，命题成立，否则说明$T$中的宽度也为$d$，令$T$中最长的反链为$A$。
		
		考虑集合：
		
		$$S^+=\left \{  x\in S|(\exists a\in A)a\preceq x\right \}$$
		
		$$S^-=\left \{  x\in S|(\exists a\in A)a\succeq x\right \}$$
		
		有以下性质：$s^+\cup S^- = S,S^+\cap S^- = A,|S^+|,|S^-|<S$
		
		对$S^+,S^-$分别应用归纳假设，则这两个集合的最小链覆盖数为$d$，且这些链中恰好包含一个$A$中的元素$a$，设这些链分别为$C_a^+,C_a^-$，则$\left \{ C_a^-\cup \left \{a\right \}\cup C_a^+\right \}$是$S$的一个最小链覆盖，命题得证。

正向求最长不上升子序列（反向求最长不下降子序列），再正向求最长上升子序列即可。

???success "<span style="color: #76ee00;">**LuoguP1020 导弹拦截**</span>引理实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    int n,a[N],dp[N],f[N],ans;
    int main()
    {
        while(cin>>a[++n]);
        n--;
        for(int i=1;i<=n;i++) f[i]=1e9;
        dp[n]=1,f[1]=a[n],ans=1;
        for(int i=n-1;i>=1;i--)
        {
            if(a[i]<f[1]) dp[i]=1,f[1]=a[i];
            else
            {
                int cur=upper_bound(f+1,f+n+1,a[i])-f-1;
                dp[i]=cur+1;
                f[dp[i]]=min(f[dp[i]],a[i]);
            }
            ans=max(ans,dp[i]);
        }
        cout<<ans<<endl;
        for(int i=1;i<=n;i++) f[i]=1e9,dp[i]=0;
        dp[1]=1,f[1]=a[1],ans=1;
        for(int i=2;i<=n;i++)
        {
            if(a[i]<=f[1]) dp[i]=1,f[1]=a[i];
            else
            {
                int cur=lower_bound(f+1,f+n+1,a[i])-f-1;
                dp[i]=cur+1;
                f[dp[i]]=min(f[dp[i]],a[i]);
            }
            ans=max(ans,dp[i]);
        }
        cout<<ans;
        return 0;
    }
	```


???success "<span style="color: #76ee00;">**LuoguP1020 导弹拦截**</span>二分实现"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+5;
    int n,a[N],dp[N],f[N],ans;
    int main()
    {
        while(cin>>a[++n]);
        n--;
        for(int i=1;i<=n;i++) f[i]=1e9;
        dp[n]=1,f[1]=a[n],ans=1;
        for(int i=n-1;i>=1;i--)
        {
            if(a[i]<f[1]) dp[i]=1,f[1]=a[i];
            else
            {
                int cur=upper_bound(f+1,f+n+1,a[i])-f-1;
                dp[i]=cur+1;
                f[dp[i]]=min(f[dp[i]],a[i]);
            }
            ans=max(ans,dp[i]);
        }
        cout<<ans<<endl;
        for(int i=1;i<=n;i++) f[i]=0;
        ans=1;f[1]=a[1];
        for(int i=2;i<=n;i++)
        {
            if(a[i]>f[ans]) f[++ans]=a[i];
            else
            {
                int cur=lower_bound(f+1,f+ans+1,a[i])-f;
                f[cur]=a[i];
            }
        }
        cout<<ans;
        return 0;
    }
	```

