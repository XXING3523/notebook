线性动态规划

<span style="color: orange;">**P2285 打鼹鼠**</span>

**【题目大意】**$n \times n$ 网格中，某些时刻鼹鼠会在某一个网格出现。你可控制一个机器人打鼹鼠，若 $i$ 时刻鼹鼠在某网格中出现，而机器人也处于同一网格，则此鼹鼠可被杀死。

机器人每一时刻只能像相邻位置移动一格或原地不动，即 $(i, j)$ 网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 网格，机器人不能走出整个 $n \times n$ 网格。

你可自由选定机器人的初始位置。

现在知道$m$只鼹鼠出现的时间$t_i$（按不降序给出）和地点$(x_i,y_i)$，求杀死鼹鼠最大值。（注：同一地点在同一时刻仅会出现最多1只鼹鼠）

记$dp_i$为处理完第$i$只鼹鼠后的杀死数最大值。

$$dp_i=\max(1,\max\limits _{|x_i-x_j|+|y_i-y_j|\le t_i-t_j}^{1\le j<i}dp_j+1)$$

最终结果为$\max\limits_{1\le i\le n}dp_i$

<span style="color:#76ee00 ;">**【单调队列优化】P1725 琪露诺**</span>

**【题目大意】**对于序列$A=\left \{ a_0, a_1,a_2,\cdots,a_n\right \},a_0=0$，从0下标出发，当位于$i$下标时，可以跳跃到$[i+L,i+R]$下标处并收集到达点的点数$a_k$，求最终跳出序列，即$i>n$时收集点数和的最大值。

设$dp_i$表示到达下标$i$时，收集点数的最大值，有：

$$dp_i=\max\limits _{i-R\le j\le i-L}dp_j+a_i$$

需要使用单调队列维护区间$dp_{max}$，算法时间复杂度为$O(n)$

???success "参考解答"
	```
	#include<bits/stdc++.h>
    using namespace std;
    const int N=2e5+5;
    int a[N];
    int q[N],len,head=1,tail=0,dp[N],n,l,r,ans=-1e9;
    void add(int x)
    {
        while(dp[q[tail]]<=dp[x]&&head<=tail) 
            tail--;
        q[++tail]=x;
        while(q[head]<=x-len) head++;
    }
    int main()
    {
        scanf("%d%d%d",&n,&l,&r);
        len=r-l+1;
        for(int i=0;i<=n;i++) scanf("%d",&a[i]);
        for(int i=1;i<=n;i++) dp[i]=-1e9;
        for(int i=l;i<=n;i++)
        {
            add(i-l);
            dp[i]=dp[q[head]]+a[i];
        }
        for(int i=n-r+1;i<=n;i++)
            ans=max(dp[i],ans);
        printf("%d",ans);
        return 0;
    }
	```
