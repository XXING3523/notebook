数字逻辑第八章 CPU

取指令

PC+“1”送PC

指令译码

进行主存地址运算

取操作数

进行算术/逻辑运算

（与进行主存地址运算不共存，要进行这一步只能从寄存器中取数）

存结果

每步都需要检测异常

若有异常，自动切换到异常处理程序，硬件检测是否有中断请求，有则转中断处理。

异常和中断的差别是什么？异常是在CPU内部发生的，中断是由外部事件引起的

CPU 由 执行部件 和 控制部件组成

控制器主要 由 指令译码器 和 控制信号形成部件 组成

数据通路（DataPath）——指令的执行部件（操作元件（组合逻辑）（如ALU）存储（状态）元件（时序逻辑）寄存器）

控制器（Control Unit）——指令的控制部件（控制部件（控制器）译码部件（组合逻辑）控制信号生成部件（组合逻辑）存储（状态）元件（时序逻辑）寄存器）

数据通路是由操作元件和存储元件通过总线方式或分散方式连接而成的进行数据存储、处理、传送的路径。







立即数拼接器：拿到32位输入，按照5种立即数的拼接方式，输出一个正确的32位立即数，需要借助ExtOP进行方式选择。



R-型指令的数据通路：

add/slt/sltu属于R型指令，Result为什么要回送，替换掉什么？RegWr是写使能，为什么寄存器组需要？涉及寄存器多，在大多数时候需要关闭写使能信号。将三条R-指令各自选择一条ALUctr信号即可，三条指令都要写结果，故写使能信号均为1

I-型运算指令ori功能：
为什么需要二路选择器？为了维持原范式，我们不做大的删改，而是增添选择端，为了将busB替换成Imm，不直接换，而是增加一个二路选择器。需要时使下方通即可。

选择段控制信号：ALUBsrc，等于1从扩展器来，否则从busB来。ExtOp=000（immI），Regwr=1

ALUctr为or

U-型指令的数据通路：

立即数拼接器完成了主要的步骤，此时ALUctr为srcB（不用进行任何操作，直接送），ExtOp为immU，ALUBsrc=1，Regwr=1

附加auipc功能：

上口送PC，在busA处也要加一个二路选择器，选择是否送PC，将ALUctr置为add

Load指令的数据通路：

R[rd]← M[R[rs1]+SEXT(imm12)]

涉及到内存。数据存储器（理想存储器，受Clk控制，此处暂当成跟寄存器组一样功能的部件，但其只需要addr，data与WrEn端，实现任意地址读写）

在result处也要增加一个二路选择器。

ALUctr是add，第二操作数为immI（既可以是运算类型，也可以是load类型），故ExtOp为000；ALUBSrc=1；MemWr为0；MemtoReg为1；RegWr为1

Store指令的数据通路

S-型的sw指令的功能：M[R[rs1]+SEXT(imm12)]←R[rs2] 

![image-20251121105012662](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121105012662.png)

注意ExtOp为immS

此时这些Data In等等数据传输的线上一定存在各种各样的数据，因此要特别注意各个写使能，及时关闭之。故要及时关闭RegWr。

B-型指令（有条件跳转）的数据通路：


![image-20251121105821585](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121105821585.png)

刚才imm部分无来源，现在得知是从指令存储器中来的，毕竟所需的imm就是在指令中。

Branch信号仅在使用B型指令时为1，为进行PC加数的选择。只有Branch和Zero同时为PC+=imm，否则PC+=4。

4在哪里？在下地址逻辑中。

![image-20251121111921816](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121111921816.png)

J-型指令的数据通路

J-型指令jal：PC←PC+SEXT(imm[20:1]<<1)；R[rd]←PC+4

![image-20251121112202437](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121112202437.png)

Jump信号仅在使用J型指令时为1

将前面的图做改变，此为终。

![image-20251121112809090](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121112809090.png)

只要Jump是1，直接送。

![image-20251121112856943](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121112856943.png)

指令开始时，取指令部件中的动作：

第一个周期到来时，PC被初始化为某个数值，然后立刻送到指令存储器。对于各指令部件相关的控制信号，都是旧值，会不会得到错误的PC值？不会，为什么？在下一个Clk到来之前PC输入端的值不会写入，只要保证在下一个Clk到来之前能产生正确的PC即可。

操作定时（时钟周期）分析













所有控制信号的解释：

**RegWr：写寄存器信号**

ALUctr：运算类型信号

ALUAsrc：是否取

ALUBsrc

ExtOP：扩展类型选择（5种：immI，immU，immS，immB，immJ）

MemWr：是否写数据存储器

MemtoReg：是否从存储器中读数存寄存器

Branch：

Jump：



op：

func3：

func7：

控制机设计（负责生成全部的控制信号）

单值控制信号逻辑表达式的生成例子

先实现指令译码（类比7-128译码），再将其搭配逻辑门连接各控制信号。



选用lw指令进行分析

PC的改变 Clk-to-Q

拆解指令得到

计算各控制信号并等待其稳定（受控制逻辑延迟影响）

busA，busB（受扩展器与多路选择器的延迟影响）得到新值

Address（受ALU Delay影响，注意：其Delay时长从busAB全部到达起算）

busW（受数据存储器延迟影响）





单周期处理器的CPI为多少？$\boxed{1}$

其他条件一定的情况下，CPI越小，性能越好。



单周期计算机性能分析：

假设在单周期处理器中，各主要功能单元操作时间为： 存储单元：200ps，ALU和加法器：100ps， 寄存器堆（读/写）：50ps。假设MUX、控制单元、PC、扩展器和传输线路都没有延迟，则单周期实现方式（每条指令在一个固定长度的时钟周期内完成）中，CPU执行时间如何计算？

对于Load指令，为所有指令中时钟周期最长的，600ps，故CPU执行时间=600*程序指令条数



多周期处理器的设计

单周期处理器的劣势：时钟周期必须以最长的指令为准，故时钟周期远大于其他指令实际所需的执行时间，效率低。

解决思路：把指令执行分成多个阶段（阶段具体的解释是什么？表格中的列？），每个阶段在一个时钟周期内完成

时钟周期以最复杂阶段（200ps，有点慢了？）所花时间为准

尽量分成大致相等的若干阶段

规定每个阶段最多只能完成1次访存或寄存器堆读/写或ALU

每步都设置存储单元，每步的执行结果都在下个时钟开始保存到相应单元（不能直接送达目的地，需要**暂存（MAR）**）

多周期处理器的好处：时钟周期（变）短，不同指令所用周期数可以不同（Load最多，别的可能会少）（取指令等阶段每条指令都一样） ，允许功能部件在一条指令执行过程中被重复使用（Adder +  ALU，多周期时只用一个ALU，在不同周期可重复使用），（Inst. / Data mem，多周期时合用，不同周期中重复使用）



状态转换图：

状态0、1是公共操作，状态1译码后得到不同的指令，每一个时钟到来后，进入下一个状态。

各指令的时钟数：R型-4, I型运算-4, lw-4, sw-4, Jump-3



![image-20251205101828292](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251205101828292.png)

微程序控制器——微指令，微命令：

不译法

下条微地址的确定方式：通过在本条微指令中明显或隐含地指定下条微指令在控存中的地址来控制。

两种产生方式：

（1）增量（计数器）法：隐含在微程序计数器$\mu PC$中

（2）断定（下址字段）法：在本条微指令中明显指定。

四种情况：

（1）取指微程序首址：每条指令执行前，CPU先执行取指微程序

（2）第一条微指令：每条指令取出后，必须转移到该指令对应的第一条微指令执行。

（3）顺序执行时：微程序执行过程中顺序取出下条微指令执行。

（4）分支执行时：在遇到按条件转移到不同微指令执行时，需要根据控制单元的输入来选择下条微指令。



每条指令对应一段微指令构成的微程序（不可被修改）。

异常和中断的处理：

中断（遇特殊情况），CPU终止正在进行的程序，转而处理异常情况或特殊事件的程序，完成后再回到端点继续。



异常的基本处理：

（1）关中断（“中断/异常允许”状态位清0）：防止新异常(或中断)破坏断点、程序状态和现场（现场指通用寄存器的值）。

（2）保护断点和程序状态：将断点和程序状态保存到堆栈或特殊寄存

PC→栈 或 专门存放断点的寄存器。	

PSWR →栈 或 EPSWR （专门保存程序状态的寄存器）

（3）识别异常事件：软件识别/硬件识别（向量中断方式）









流水线：

为使流水线顺利工作（**解决结构冒险**），规定：

- 每个功能部件每条指令只能用一次（写口不能同时被写两次及以上）
- 每个功能部件必须在特定阶段被使用（即使指令不同，如写口总是在第五阶段使用）
- 将寄存器读口、写口独立，将Instruction Memory与Data Memory分开

添加NOP指令进行延迟，使流水线更规整。

![image-20251205115644515](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251205115644515.png)

![image-20251205115709234](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251205115709234.png)

理想流水线的CPI为1.（因在若干阶段后，每一阶段均完成了一条指令）

beq到底有几个阶段？3？4？5？控制冒险

流水线为什么要在每个阶段中间插入对应的寄存器（流水段寄存器）？

流水线控制器：



保存每个周期执行的结果。

控制冒险、数据冒险。

最开始时刻，所有流水段寄存器初始化为0（信号不能随意置为1，其中（WE）write enable错置为1造成的错写是无法挽回的）

IF（取指令）：

ID（译码取数）：完成取操作数，解码指令与控制信号

EX（执行）：

M：

WB：

**结构冒险/资源冲突（已提前解决）**：**一个功能部件同时被不同指令使用**（两条指令试图在同一个时钟周期写寄存器，**若不对寄存器堆写口、读口独立设置，则发生冲突！**）

**数据冒险：后面指令用前面指令结果数据是，前面指令结果还未产生**（在途中如果某一指令在WB阶段写寄存器，而同时在其后方的指令正在使用此寄存器时，可能发生同一个寄存器同时被读与写，**但先后顺序无法保证，可能导致出错**。）

**控制冒险（分支冒险、转移冒险）：转移或异常改变执行流程，后继指令在目标地址产生前已被取出**B-指令在取数阶段**尚未确定是否应跳转**，**而紧随其后的指令已经进入流水线，取错了指令！**

在保证正确工作前提下，

单周期与流水线计算机的性能对比：

**单周期时钟周期为各阶段时钟周期之和，流水线时钟周期为各阶段时钟周期最大值＋流水段寄存器延迟。**

**【考试重点】识别数据冒险现象：**

```c++
add r1,r2,r3
sub r4,r1,r3
and r6,r1,r7
or  r8,r1,r9
xor r10,r1,r11
```

前三条指令是r1旧值，第五条指令是r1新值，**第2、3条指令计算错误，第4条指令不一定能读到新值，我们认为此错误**（在读后写的情况下），**共出现3对冒险**

三类数据冒险现象（**仅考虑RAW冒险**）：

**（1）RAW:  写后读（基本流水线中经常发生，如上例）**

（2）WAR：读后写（基本流水线中不会发生，乱序执行时会发生）

（3）WAW：写后写（基本流水线中不会发生，乱序执行时会发生）

解决方案：

（1）**（纯硬件）硬件阻塞（插入气泡bubble）（阻止后续指令执行，延迟到有新值之后）**

使用专门的组合逻辑电路计算阻塞周期数。阻塞时，使流水段寄存器全部填充0。

缺陷：控制较复杂，需修改数据通路，指令被延迟执行，造成时间损耗。

```c++
add r1,r2,r3
stall
stall
stall
sub r4,r1,r3
and r6,r1,r7
or  r8,r1,r9
xor r10,r1,r11
```

（2）**（纯软件）**软件插入NOP指令

由编译器插入NOP指令

优势：无需修改硬件（数据通路），与硬件阻塞相比没有时间优化。

```c++
add r1,r2,r3
nop
nop
nop
sub r4,r1,r3
and r6,r1,r7
or  r8,r1,r9
xor r10,r1,r11
```

（3）**（纯硬件）（与其他方案搭配）（不能解决所有数据冒险）**合理实现寄存器堆读/写操作

寄存器写口/读口分别在前/后半周期进行操作，使写入数据被直接读出**（可以消除or运算的数据冒险）**

**与方案一结合时将只插入2行气泡。**

（4）**【考试重点】（纯硬件）（不能解决所有数据冒险）转发（Forwarding转发或Bypassing旁路）技术**

利用DataPath的中间数据：可以在流水段寄存器中找到r1的新值，当add指令计算出r1的新值时，此值暂存EX/M寄存器，此时sub在计算，从段寄存器取r1的值即可，and的计算同理。

（5）**（纯软件）（不能解决所有数据冒险）**编译优化：调整指令顺序







