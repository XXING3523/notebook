数字逻辑第八章 CPU

取指令

PC+“1”送PC

指令译码

进行主存地址运算

取操作数

进行算术/逻辑运算

（与进行主存地址运算不共存，要进行这一步只能从寄存器中取数）

存结果

每步都需要检测异常

若有异常，自动切换到异常处理程序，硬件检测是否有中断请求，有则转中断处理。

异常和中断的差别是什么？异常是在CPU内部发生的，中断是由外部事件引起的

CPU 由 执行部件 和 控制部件组成

控制器主要 由 指令译码器 和 控制信号形成部件 组成

数据通路（DataPath）——指令的执行部件（操作元件（组合逻辑）（如ALU）存储（状态）元件（时序逻辑）寄存器）

控制器（Control Unit）——指令的控制部件（控制部件（控制器）译码部件（组合逻辑）控制信号生成部件（组合逻辑）存储（状态）元件（时序逻辑）寄存器）

数据通路是由操作元件和存储元件通过总线方式或分散方式连接而成的进行数据存储、处理、传送的路径。







立即数拼接器：拿到32位输入，按照5种立即数的拼接方式，输出一个正确的32位立即数，需要借助ExtOP进行方式选择。



R-型指令的数据通路：

add/slt/sltu属于R型指令，Result为什么要回送，替换掉什么？RegWr是写使能，为什么寄存器组需要？涉及寄存器多，在大多数时候需要关闭写使能信号。将三条R-指令各自选择一条ALUctr信号即可，三条指令都要写结果，故写使能信号均为1

I-型运算指令ori功能：
为什么需要二路选择器？为了维持原范式，我们不做大的删改，而是增添选择端，为了将busB替换成Imm，不直接换，而是增加一个二路选择器。需要时使下方通即可。

选择段控制信号：ALUBsrc，等于1从扩展器来，否则从busB来。ExtOp=000（immI），Regwr=1

ALUctr为or

U-型指令的数据通路：

立即数拼接器完成了主要的步骤，此时ALUctr为srcB（不用进行任何操作，直接送），ExtOp为immU，ALUBsrc=1，Regwr=1

附加auipc功能：

上口送PC，在busA处也要加一个二路选择器，选择是否送PC，将ALUctr置为add

Load指令的数据通路：

R[rd]← M[R[rs1]+SEXT(imm12)]

涉及到内存。数据存储器（理想存储器，受Clk控制，此处暂当成跟寄存器组一样功能的部件，但其只需要addr，data与WrEn端，实现任意地址读写）

在result处也要增加一个二路选择器。

ALUctr是add，第二操作数为immI（既可以是运算类型，也可以是load类型），故ExtOp为000；ALUBSrc=1；MemWr为0；MemtoReg为1；RegWr为1

Store指令的数据通路

S-型的sw指令的功能：M[R[rs1]+SEXT(imm12)]←R[rs2] 

![image-20251121105012662](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121105012662.png)

注意ExtOp为immS

此时这些Data In等等数据传输的线上一定存在各种各样的数据，因此要特别注意各个写使能，及时关闭之。故要及时关闭RegWr。

B-型指令（有条件跳转）的数据通路：


![image-20251121105821585](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121105821585.png)

刚才imm部分无来源，现在得知是从指令存储器中来的，毕竟所需的imm就是在指令中。

Branch信号仅在使用B型指令时为1，为进行PC加数的选择。只有Branch和Zero同时为PC+=imm，否则PC+=4。

4在哪里？在下地址逻辑中。

![image-20251121111921816](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121111921816.png)

J-型指令的数据通路

J-型指令jal：PC←PC+SEXT(imm[20:1]<<1)；R[rd]←PC+4

![image-20251121112202437](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121112202437.png)

Jump信号仅在使用J型指令时为1

将前面的图做改变，此为终。

![image-20251121112809090](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121112809090.png)

只要Jump是1，直接送。

![image-20251121112856943](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251121112856943.png)

指令开始时，取指令部件中的动作：

第一个周期到来时，PC被初始化为某个数值，然后立刻送到指令存储器。对于各指令部件相关的控制信号，都是旧值，会不会得到错误的PC值？不会，为什么？在下一个Clk到来之前PC输入端的值不会写入，只要保证在下一个Clk到来之前能产生正确的PC即可。

操作定时（时钟周期）分析













所有控制信号的解释：

**RegWr：写寄存器信号**

ALUctr：运算类型信号

ALUAsrc：是否取

ALUBsrc

ExtOP：扩展类型选择（5种：immI，immU，immS，immB，immJ）

MemWr：是否写数据存储器

MemtoReg：是否从存储器中读数存寄存器

Branch：

Jump：



op：

func3：

func7：

控制机设计（负责生成全部的控制信号）

单值控制信号逻辑表达式的生成例子

先实现指令译码（类比7-128译码），再将其搭配逻辑门连接各控制信号。



选用lw指令进行分析

PC的改变 Clk-to-Q

拆解指令得到

计算各控制信号并等待其稳定（受控制逻辑延迟影响）

busA，busB（受扩展器与多路选择器的延迟影响）得到新值

Address（受ALU Delay影响，注意：其Delay时长从busAB全部到达起算）

busW（受数据存储器延迟影响）





单周期处理器的CPI为多少？$\boxed{1}$

其他条件一定的情况下，CPI越小，性能越好。



单周期计算机性能分析：

假设在单周期处理器中，各主要功能单元操作时间为： 存储单元：200ps，ALU和加法器：100ps， 寄存器堆（读/写）：50ps。假设MUX、控制单元、PC、扩展器和传输线路都没有延迟，则单周期实现方式（每条指令在一个固定长度的时钟周期内完成）中，CPU执行时间如何计算？

对于Load指令，为所有指令中时钟周期最长的，600ps，故CPU执行时间=600*程序指令条数



多周期处理器的设计

单周期处理器的劣势：时钟周期必须以最长的指令为准，故时钟周期远大于其他指令实际所需的执行时间，效率低。

解决思路：把指令执行分成多个阶段（阶段具体的解释是什么？表格中的列？），每个阶段在一个时钟周期内完成

时钟周期以最复杂阶段（200ps，有点慢了？）所花时间为准

尽量分成大致相等的若干阶段

规定每个阶段最多只能完成1次访存或寄存器堆读/写或ALU

每步都设置存储单元，每步的执行结果都在下个时钟开始保存到相应单元（不能直接送达目的地，需要**暂存（MAR）**）

多周期处理器的好处：时钟周期（变）短，不同指令所用周期数可以不同（Load最多，别的可能会少）（取指令等阶段每条指令都一样） ，允许功能部件在一条指令执行过程中被重复使用（Adder +  ALU，多周期时只用一个ALU，在不同周期可重复使用），（Inst. / Data mem，多周期时合用，不同周期中重复使用）



状态转换图：

状态0、1是公共操作，状态1译码后得到不同的指令，每一个时钟到来后，进入下一个状态。

各指令的时钟数：R型-4, I型运算-4, lw-4, sw-4, Jump-3



![image-20251205101828292](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251205101828292.png)

微程序控制器——微指令，微命令：

不译法

下条微地址的确定方式：通过在本条微指令中明显或隐含地指定下条微指令在控存中的地址来控制。

两种产生方式：

（1）增量（计数器）法：隐含在微程序计数器$\mu PC$中

（2）断定（下址字段）法：在本条微指令中明显指定。

四种情况：

（1）取指微程序首址：每条指令执行前，CPU先执行取指微程序

（2）第一条微指令：每条指令取出后，必须转移到该指令对应的第一条微指令执行。

（3）顺序执行时：微程序执行过程中顺序取出下条微指令执行。

（4）分支执行时：在遇到按条件转移到不同微指令执行时，需要根据控制单元的输入来选择下条微指令。



每条指令对应一段微指令构成的微程序（不可被修改）。

异常和中断的处理：

中断（遇特殊情况），CPU终止正在进行的程序，转而处理异常情况或特殊事件的程序，完成后再回到端点继续。



异常的基本处理：

（1）关中断（“中断/异常允许”状态位清0）：防止新异常(或中断)破坏断点、程序状态和现场（现场指通用寄存器的值）。

（2）保护断点和程序状态：将断点和程序状态保存到堆栈或特殊寄存

PC→栈 或 专门存放断点的寄存器。	

PSWR →栈 或 EPSWR （专门保存程序状态的寄存器）

（3）识别异常事件：软件识别/硬件识别（向量中断方式）









流水线：

可能出现的问题：资源冲突（如两条指令试图在同一个周期写寄存器）

结构冒险：一个功能部件同时被多条指令使用的现象。

为使流水线能顺利工作，规定：

- 每个功能部件每条指令只能用一次（写口不能同时被写两次及以上）
- 每个功能部件必须在相同阶段被使用（即使指令不同）（写口总是在第五阶段使用）

通过对指令添加NOP指令进行延迟，并使流水线更规整。

![image-20251205115644515](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251205115644515.png)

![image-20251205115709234](C:\Users\27203\AppData\Roaming\Typora\typora-user-images\image-20251205115709234.png)

