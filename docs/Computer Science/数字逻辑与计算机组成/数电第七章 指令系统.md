数字逻辑第七章 指令系统

概述与指令系统设计

指令执行周期：

（1）取指令（IF）：指令地址、指令长度（定长/变长）

（2）指令译码（ID），确定做何操作：指令格式、操作数编码、操作数类型

（3）取数，计算操作数地址并取操作数：地址码、寻址方式、操作数格式与存放

（4）执行（EX），进行相应计算、并得到标志位：操作类型、标志或条件码

（5）存数（RS），将计算结果保存到目的地：结果数据位置（目的操作数地址）

（6）下一步，计算下一条指令地址（与取指令同时进行）：下条指令地址（顺序/转移）



寻址方式

**立即**：地址码给出操作数本身

**直接**：地址码给出操作数所在内存单元地址

**间接**：略

**寄存器（直接）**：地址码给出操作数所在寄存器编号

**寄存器间接**：**地址码给出操作数所在单元地址所在的寄存器编号，从给定编号寄存器中读取内存地址再去内存单元寻找此地址，取其数。**

两种间接寻址都是从内存单元/寄存器中先读取地址，再循此地址去内存单元取操作数。

**栈**：操作数约定在栈中，从栈顶取数或存数

**偏移寻址**：用基地址+形式地址得操作数所在内存单元地址，（R）可明显给出，也可隐含给出：**PC、基址寄存器B、变址寄存器**。

**相对寻址：**

指令地址码给出一个偏移量(带符号数)，基准地址R隐含由PC（所谓的EIP）给出。

即：EA=(PC)+A——相对于当前指令处位移量为A的单元

**可用来实现程序(公共子程序)的浮动或指定转移目标地址，如jump指令，call指令等**

注意：当前PC的值可以是正在执行指令的地址或下条指令的地址

**基址寻址（这个没搞懂）：**

指令地址码给出一个偏移量，基准地址R明显或隐含由基址寄存器B给出

即：EA=(B)+A——相对于基址(B)处位移量为A的单元

可用来实现多道程序重定位或过程调用中参数的访问

**变址寻址（这个没搞懂）：**

指令地址码给出一个基准地址，而偏移量(无符号数)R明显或隐含由变址寄存器I给出。

即：EA=(I)+A——相对于**首址A**处位移量为(I)的单元（I）可记为元素字节长度，可循环增长或减小。

可为循环重复操作提供一种高效机制，如实现**对线性表的操作**

|    方式    |              算法              |        优点        |      缺点      |                   操作数位置                   |
| :--------: | :----------------------------: | :----------------: | :------------: | :--------------------------------------------: |
|   立即数   |            操作数=A            |     指令执行快     | 操作数值域有限 | 指令**（寄存器）（这个地方怎么做数？？？）**中 |
|    直接    |        EA（有效地址）=A        |    地址计算简单    |  地址范围有限  |                     内存中                     |
|    间接    | EA=（A），（X）指的是X中的内容 |     地址范围大     | 多次存储器访问 |                     内存中                     |
| 寄存器直接 |   操作数=（R（寄存器编号））   | 指令执行快，指令短 |  地址范围有限  |                    寄存器中                    |
| 寄存器间接 |            EA=（R）            |     地址范围大     | 额外存储器访问 |                     内存中                     |
|    偏移    |           EA=A+（R）           |        灵活        |      复杂      |                     内存中                     |
|     栈     |            EA=栈顶             |       指令短       |    应用有限    |                     内存中                     |

存储器指的就是内存单元吗？





```c++
J型：PC<-PC+SEXT[imm[20:1]<<1];R[rd]<-PC+4;
```











