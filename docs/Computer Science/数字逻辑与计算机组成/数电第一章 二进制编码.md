1.1 计算机系统概述

**冯诺依曼结构思想：**

**（1）（最重要）“存储程序”工作方式。**

任何要计算机完成的工作都应**事先被编写成程序**，将程序与原始数据**送入主存**后才可**执行**程序；一旦程序启动，计算机能**自动**完成逐条取指令与执行指令的任务。

（2）五个基本部件，**运算器、控制器**（正确取指令并执行）、**存储器**（可存数据与指令，形式上二者无区别，但应能区分）、**I/O**（操作人员通过此与主机通信）（CPU包括运算器、控制器、寄存器）

（3）内部以二进制表示指令、数据，**指令由操作码、地址码构成**，描述如何对数据处理。由一串指令组成程序。

（4）早期，部件之间用分散方式相连，**后改进为总线方式相连，在后改为总线+点对点高速连接**。

存储器分类：寄存器（64bit/32bit）、内存、外存（硬盘）

GPRs 通用寄存器组

MAR 存储器地址寄存器

MDR 存储器数据寄存器

ALU 算术逻辑部件（单元）

CPU 中央处理器

IR 指令寄存器

PC 程序计数器

**计算机工作流程：**

程序执行前：

（1）数据、指令事先存放于存储器中；

（2） 每条指令和每个数据都有地址；

（3）指令按序存放（**不一定按序执行**）；

（4）程序起始地址（第一条指令地址）置入PC

步骤（在控制器协调下）：

（1）根据PC取指令（指令与数据分别从存储器，即IR、GPR中取到CPU寄存器中）

（2）指令译码（从中得到操作码、地址码，地址码包括源操作数1/源操作数2、目的操作数地址）

（3）按地址取操作数（不一定有）

（4）执行指令

（5）按地址回写结果（不一定有）

（6）修改PC，回到（1）

ISA——指令集体系结构是一种规约：

- **可执行的指令的集合**，（指令格式、操作种类以及每种操作对应的操作数的相应规定）;

- 指令可以接受的**操作数类型**；

- 操作数所能存放的**寄存器组的结构**，包括每个寄存器的名称、编号、长度和用途；

- 操作数所能存放的**存储空间的大小和编址方式**；

- 操作数在存储空间存放时**按照大端还是小端方式存放**；

- **寻址方式**；

- **指令执行过程的控制方式**，包括程序计数器、条件码定义等。

机器级语言包括机器语言与汇编语言，二者是一一对应的（？），即每一个汇编语言都对应一串机器语言

**高级语言源程序（编译）$\to$汇编语言源程序（汇编）$\to$机器语言目标程序（译码）$\to$控制信号**

编译程序(Complier)：高级语言源程序→汇编/机器目标程序

汇编程序(Assembler)：汇编语言源程序→机器目标程序

解释程序(Interpreter )：将高级语言语句逐条翻译成机器指令并立即执行,不生成目标文件。

##### 1.2  数据的机器级表示与处理

机器数指的是用0、1编码的序列，真值指的是按照不同编码方式解码得到的真正的值

**本节重点：**
**用原码与定点小数，整数真值的互相转换**
**补码转真值、真值转补码**
**二进制数的移码书写**
**带有浮点数的相关知识：**
**① IEEE754规格化转换，例外情况与相应数据分配**
**② 各种形式码的表数范围**
**③ 模拟各类型变量进行运算的最终结果（一般来说不是直接运算的结果，会出现各种因类型限制而改变的现象）**
**④ 浮点数精确度分析**
**小端大端存放数据模拟**

机器级数据分两大类：数值数据与非数值数据

数值数据分为**二进制数**与**二进制编码的十进制数**（BCD码运算指令）

二进制数分为**整数（定点数）、实数（浮点数）**

整数分为**无符号（地址运算、编码表示），带符号**

###### **1.2.1 数值数据的表示与存储**

???info "使用二进制编码的原因"
	（1）制造两个稳定态的物理器件容易；

	（2）二进制编码、计数、运算规则简单；
	
	（3）正好与逻辑命题对应，便于逻辑运算，并可方便地用逻辑电路实现算术。

进制转换（十进制转R进制）：乘法，除基取余，上右下左；除法，乘基取整，上左下右。

**定点数表示三明确（不给出则无法确定数值数据的真值）：**

**① 进位计数制；② 定、浮点表示；③ 如何使用二进制编码（原码、补码……）**

定点数的表示

原码：第一位为符号位，后为数值位。

原码表示定点整数时，小数点固定在数值位最右；表示定点小数时，小数点固定在数值位最左。

四个问题：

（1）0表示不唯一（2） 需要额外处理符号位（3）加减不统一、**（4） $a$小于$b$时实现$a-b$困难**

**目前用于表示浮点数尾数。**

补码

$n$位补码表数范围$[-2^{n-1},2^{n-1}-1]$，数学计算为$[X]_{补}=2^n+X(\text{mod }2^n)$

**用于表示定点整数（带符号整数）**

???info "为什么用补码表示带符号整数？"
	（1）补码是模运算系统，加、减运算统一

	（2）0表示唯一，方便使用
	
	（3）比原码多表示一个最小负数（原码+0和-0表示不一样）
	
	（4）与移码相比，其符号位和真值的符号对应关系更直接
	
	??? warning 
		无符号数编码无符号位，也就与原码、补码、移码三种编码方式无关，直接使用二进制数表示即可。

**（重点）补码与真值之间的相互转换**

有符号数转无符号数（int——unsigned）：保持机器数不变，可能出现负变正
编译器处理常量时，将数据类型编为链表，先满足即赋为该类型（参照《计算机系统基础》笔记本）

变形（模4）补码：双符号补码，用于存储看似错误（溢出），但最终能恢复的数据（如计算的中间结果）（在短暂溢出时可以保证相关数据的正确性）

移码

将每一个数值加上偏置常数，一般当机器数位数为$n$时，取$2^{n-1}$

$E_{\text{biased}}=E+\text{bias}$

主要用于表示浮点数阶码，简化浮点数编码与计算。

无符号整数左/右移均**补零**；**有符号整数左移补零，右移补符号位。**

**不同类型数值的相互转换**

**带符号整数：符号扩展**（因其采用补码表示，可保证真值不变），**无符号整数：零扩展**



浮点数的表示

**规格化：尾数的小数点前只有一位非0数**

需给出阶码位数与偏置常数、尾数位数。尾数开头的1不显示表示。

IEEE754浮点数标准

单精度：

| S（1） | Exponent（8），Biase=127 | Significard（23），隐含1 |
| :----: | :----------------------: | :----------------------: |



| Exponent | Significand |      Object       |
| :------: | :---------: | :---------------: |
|  1~254   |  隐藏首位1  |     规格化数      |
|    0     |      0      |       +0/-0       |
|    0     |   nonzero   |    非规格化数     |
|   255    |      0      | $+\infty/-\infty$ |
|   255    |   nonzero   |      NaN非数      |

浮点数除以0的结果是正无穷/负无穷，整数除以0的结果是异常。

NaN举例：$\text{sqrt(-4.0),0/0},\infty/\infty$

浮点数表数范围与阶码范围有关、精度与尾数位数和如何规格化有关。

IEEE754Float非规格化数表数范围：$(-1)^s\cdot 0.XX\cdots X\cdot 2^{-126}$

规格化数的最大正数（最小负数表示）：$(-1)^s\cdot1.11\cdots 1\cdot 2^{127}$

**数据类型相互转换（包括不同数据类型进行计算）时可能出现精度损失。**

十进制数的二进制编码（BCD码）

编码思想：每个十进制数至少有4位二进制表示。

编码方案：

（1）**十进制有权码（加权码）**，如8421码，亦称自然BCD码

（2）**十进制无权码**，每个十进制数位的4个基2码没有确定的权，常用的有余3码，格雷码。

- **余3码**：由8421码加上0011形成，当两个十进制数字和为10时，和的二进制编码正好为16，且二者余3码互为反码。
- **格雷码**：任意两个相邻的编码只有一位二进制位不同，有多种编码方式。

###### 1.2.2 非数值数据的表示、数据的存储
主要包括逻辑数据、西文字符（**熟悉对应ASCII码**）、汉字

数据的基本宽度（bit、Byte）

字常用于作为数据的长度单位，1个字一般是16bit

字与字长的区别：字长指指定点运算数据通路的宽度，字用来度量数据类型宽度。
???info 
	CPU内部有进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致，才能相互匹配。因此，”字长”等于CPU内部定点运算部件的位数、通用寄存器的宽度等。

最低有效位（LSB），最高有效位（MSB），高到低位从左到右是人类正常书写数据的方式，此可类比大端方式。

大端方式：MSB所在的地址是数的地址

小端方式：LSB所在的地址是数的地址

